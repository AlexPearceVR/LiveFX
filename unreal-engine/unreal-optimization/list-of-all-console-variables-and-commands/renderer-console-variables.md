# Renderer Console Variables

<table data-full-width="true"><thead><tr><th width="322">Name</th><th>Help</th></tr></thead><tbody><tr><td>r.AllowCachedUniformExpressions</td><td>Allow uniform expressions to be cached.</td></tr><tr><td>r.AllowClearLightSceneExtentsOnly</td><td></td></tr><tr><td>r.AllowDepthBoundsTest</td><td>If true, use enable depth bounds test when rendering defered lights.</td></tr><tr><td>r.AllowGlobalClipPlane</td><td>Enables mesh shaders to support a global clip plane, needed for planar reflections, which adds about 15% BasePass GPU cost on PS4.</td></tr><tr><td>r.AllowHDR</td><td>Creates an HDR compatible swap-chain and enables HDR display output.0: Disabled (default)<br>1: Allow HDR, if supported by the platform and display<br></td></tr><tr><td>r.AllowLandscapeShadows</td><td>Allow Landscape Shadows</td></tr><tr><td>r.AllowMultiGPUInEditor</td><td>Enable experimental multi-GPU support in editor</td></tr><tr><td>r.AllowOcclusionQueries</td><td>If zero, occlusion queries will not be used to cull primitives.</td></tr><tr><td>r.AllowPointLightCubemapShadows</td><td>When 0, will prevent point light cube map shadows from being used and the light will be unshadowed.</td></tr><tr><td>r.AllowPrecomputedVisibility</td><td>If zero, precomputed visibility will not be used to cull primitives.</td></tr><tr><td>r.AllowSimpleLights</td><td>If true, we allow simple (ie particle) lights</td></tr><tr><td>r.AllowStaticLighting</td><td>Whether to allow any static lighting to be generated and used, like lightmaps and shadowmaps.<br>Games that only use dynamic lighting should set this to 0 to save some static lighting overhead.</td></tr><tr><td>r.AllowSubPrimitiveQueries</td><td>Enables sub primitive queries, currently only used by hierarchical instanced static meshes. 1: Enable, 0 Disabled. When disabled, one query is used for the entire proxy.</td></tr><tr><td>r.AllowTexture2DArrayCreation</td><td>Enable UTexture2DArray assets</td></tr><tr><td>r.AlsoUseSphereForFrustumCull</td><td>Performance tweak. If > 0, then use a sphere cull before and in addition to a box for frustum culling.</td></tr><tr><td>r.AmbientOcclusion.AsyncComputeBudget</td><td>Defines which level of EAsyncComputeBudget to use for balancing AsyncCompute work against Gfx work.<br>Only matters if the compute version of SSAO is active (requires CS support, enabled by cvar, single pass, no normals)<br>This is a low level developer tweak to get best performance on hardware that supports AsyncCompute.<br>0: least AsyncCompute<br>1: .. (default)<br>2: ..<br>3: ..<br>4: most AsyncCompute</td></tr><tr><td>r.AmbientOcclusion.Compute</td><td>If SSAO should use ComputeShader (not available on all platforms) or PixelShader.<br>The [Async] Compute Shader version is WIP, not optimized, requires hardware support (not mobile/DX10/OpenGL3),<br>does not use normals which allows it to run right after EarlyZPass (better performance when used with AyncCompute)<br>AyncCompute is currently only functional on PS4.<br>0: PixelShader (default)<br>1: (WIP) Use ComputeShader if possible, otherwise fall back to '0'<br>2: (WIP) Use AsyncCompute if efficient, otherwise fall back to '1'<br>3: (WIP) Use AsyncCompute if possible, otherwise fall back to '1'</td></tr><tr><td>r.AmbientOcclusion.Compute.Smooth</td><td>Whether to smooth SSAO output when TAA is disabled</td></tr><tr><td>r.AmbientOcclusion.Denoiser</td><td>Choose the denoising algorithm.<br>0: Disabled;<br>1: Forces the default denoiser of the renderer;<br>2: GScreenSpaceDenoiser witch may be overriden by a third party plugin (default).</td></tr><tr><td>r.AmbientOcclusion.Denoiser.HistoryConvolution.KernelSpreadFactor</td><td>Multiplication factor applied on the kernel sample offset (default = 7).</td></tr><tr><td>r.AmbientOcclusion.Denoiser.HistoryConvolution.SampleCount</td><td>Number of samples to use for history post filter (default = 16).</td></tr><tr><td>r.AmbientOcclusion.Denoiser.KernelSpreadFactor</td><td>Spread factor of the preconvolution passes.</td></tr><tr><td>r.AmbientOcclusion.Denoiser.PreConvolution</td><td>Number of pre-convolution passes (default = 1).</td></tr><tr><td>r.AmbientOcclusion.Denoiser.ReconstructionSamples</td><td>Maximum number of samples for the reconstruction pass (default = 16).</td></tr><tr><td>r.AmbientOcclusion.Denoiser.TemporalAccumulation</td><td>Accumulates the samples over multiple frames.</td></tr><tr><td>r.AmbientOcclusion.DepthBoundsTest</td><td>Whether to use depth bounds test to cull distant pixels during AO pass. This option is only valid when pixel shader path is used (r.AmbientOcclusion.Compute=0), without upsampling.</td></tr><tr><td>r.AmbientOcclusion.FadeRadiusScale</td><td>Allows to scale the ambient occlusion fade radius (SSAO).<br>0.01:smallest .. 1.0:normal (default), &#x3C;1:smaller, >1:larger</td></tr><tr><td>r.AmbientOcclusion.Method</td><td>Select between SSAO methods<br>0: SSAO (default)<br>1: GTAO<br></td></tr><tr><td>r.AmbientOcclusionLevels</td><td>Defines how many mip levels are using during the ambient occlusion calculation. This is useful when tweaking the algorithm.<br>&#x3C;0: decide based on the quality setting in the postprocess settings/volume and r.AmbientOcclusionMaxQuality (default)<br>0: none (disable AmbientOcclusion)<br>1: one<br>2: two (costs extra performance, soft addition)<br>3: three (larger radius cost less but can flicker)</td></tr><tr><td>r.AmbientOcclusionMaxQuality</td><td>Defines the max clamping value from the post process volume's quality level for ScreenSpace Ambient Occlusion<br>100: don't override quality level from the post process volume (default)<br>0..99: clamp down quality level from the post process volume to the maximum set by this cvar<br>-100..0: Enforces a different quality (the absolute value) even if the postprocessvolume asks for a lower quality.</td></tr><tr><td>r.AmbientOcclusionMipLevelFactor</td><td>Controls mipmap level according to the SSAO step id<br>0: always look into the HZB mipmap level 0 (memory cache trashing)<br>0.5: sample count depends on post process settings (default)<br>1: Go into higher mipmap level (quality loss)</td></tr><tr><td>r.AmbientOcclusionRadiusScale</td><td>Allows to scale the ambient occlusion radius (SSAO).<br>0:off, 1.0:normal, &#x3C;1:smaller, >1:larger</td></tr><tr><td>r.AmbientOcclusionStaticFraction</td><td>Allows to override the Ambient Occlusion Static Fraction (see post process volume). Fractions are between 0 and 1.<br>&#x3C;0: use default setting (default -1)<br>0: no effect on static lighting, 0 is free meaning no extra rendering pass<br>1: AO affects the stat lighting</td></tr><tr><td>r.Android.DisableASTCSupport</td><td>Disable support for ASTC Texture compression if OpenGL driver supports it. (Android Only)<br>0 = ASTC texture compression will be used if driver supports it [default]<br>1 = ASTC texture compression will not be used.</td></tr><tr><td>r.Android.DisableOpenGLES31Support</td><td>Disable support for OpenGLES 3.1 API. (Android Only)<br>0 = OpenGLES 3.1 API will be used (providing device and project supports it) [default]<br>1 = OpenGLES 3.1 will be disabled, Vulkan will be used.</td></tr><tr><td>r.Android.DisableVulkanSM5Support</td><td>Disable support for vulkan API. (Android Only)<br>0 = Vulkan SM5 API will be used (providing device and project supports it) [default]<br>1 = Vulkan SM5 will be disabled, Vulkan or OpenGL fall back will be used.</td></tr><tr><td>r.Android.DisableVulkanSupport</td><td>Disable support for vulkan API. (Android Only)<br>0 = vulkan API will be used (providing device and project supports it) [default]<br>1 = vulkan will be disabled, opengl fall back will be used.</td></tr><tr><td>r.Android.OverrideExternalTextureSupport</td><td>Override external texture support for OpenGLES API. (Android Only)<br>0 = normal detection used [default]<br>1 = disable external texture support<br>2 = force ImageExternal100 (version #100 with GL_OES_EGL_image_external)<br>3 = force ImageExternal300 (version #300 with GL_OES_EGL_image_external)<br>4 = force ImageExternalESSL300 (version #300 with GL_OES_EGL_image_external_essl3)</td></tr><tr><td>r.AndroidDisableThreadedRendering</td><td>Sets whether or not to allow threaded rendering for a particular Android device profile.<br>0 = Allow threaded rendering [default]<br>1 = Disable creation of render thread on startup</td></tr><tr><td>r.AndroidDisableThreadedRenderingFirstLoad</td><td>Sets whether or not to allow threaded rendering for a particular Android device profile on the initial load.<br>0 = Allow threaded rendering on the initial load [default]<br>1 = Disable threaded rendering on the initial load</td></tr><tr><td>r.AnisotropicMaterials</td><td>Whether anisotropic BRDF is used for material with anisotropy.</td></tr><tr><td>r.AntiAliasingMethod</td><td>Engine default (project setting) for AntiAliasingMethod is (postprocess volume/camera/game setting still can override)<br>0: off (no anti-aliasing)<br>1: Fast Approximate Anti-Aliasing (FXAA)<br>2: Temporal Anti-Aliasing (TAA)<br>3: Multisample Anti-Aliasing (MSAA, Only available on the desktop forward renderer)<br>4: Temporal Super-Resolution (TSR, Default)</td></tr><tr><td>r.AOApplyToStaticIndirect</td><td>Whether to apply DFAO as indirect shadowing even to static indirect sources (lightmaps + stationary skylight + reflection captures)</td></tr><tr><td>r.AOAsyncBuildQueue</td><td>Whether to asynchronously build distance field volume data from meshes.</td></tr><tr><td>r.AOAverageObjectsPerCullTile</td><td>Determines how much memory should be allocated in distance field object culling data structures. Too much = memory waste, too little = flickering due to buffer overflow.</td></tr><tr><td>r.AOClearHistory</td><td></td></tr><tr><td>r.AOComputeShaderNormalCalculation</td><td>Whether to use the compute shader version of the distance field normal computation.</td></tr><tr><td>r.AOGlobalDFClipmapDistanceExponent</td><td>Exponent used to derive each clipmap's size, together with r.AOInnerGlobalDFClipmapDistance.</td></tr><tr><td>r.AOGlobalDFResolution</td><td>Resolution of the global distance field. Higher values increase fidelity but also increase memory and composition cost.</td></tr><tr><td>r.AOGlobalDFStartDistance</td><td>World space distance along a cone trace to switch to using the global distance field instead of the object distance fields.<br>This has to be large enough to hide the low res nature of the global distance field, but smaller values result in faster cone tracing.</td></tr><tr><td>r.AOGlobalDistanceField</td><td>Whether to use a global distance field to optimize occlusion cone traces.<br>The global distance field is created by compositing object distance fields into clipmaps as the viewer moves through the level.</td></tr><tr><td>r.AOGlobalDistanceField.AverageCulledObjectsPerPage</td><td>Average expected number of objects per page, used to preallocate memory for the cull grid.</td></tr><tr><td>r.AOGlobalDistanceField.CameraPositionVelocityOffsetDecay</td><td></td></tr><tr><td>r.AOGlobalDistanceField.FastCameraMode</td><td>Whether to update the Global SDF for fast camera movement - lower quality, faster updates so lighting can keep up with the camera.</td></tr><tr><td>r.AOGlobalDistanceField.Heightfield</td><td>Whether to voxelize Heightfield into the global distance field.<br></td></tr><tr><td>r.AOGlobalDistanceField.MinMeshSDFRadius</td><td>Meshes with a smaller world space radius than this are culled from the global SDF.</td></tr><tr><td>r.AOGlobalDistanceField.MinMeshSDFRadiusInVoxels</td><td>Meshes with a smaller radius than this number of voxels are culled from the global SDF.</td></tr><tr><td>r.AOGlobalDistanceField.MipFactor</td><td>Resolution divider for the mip map of a distance field clipmap.</td></tr><tr><td>r.AOGlobalDistanceField.NumClipmaps</td><td>Num clipmaps in the global distance field. Setting this to anything other than 4 is currently only supported by Lumen.</td></tr><tr><td>r.AOGlobalDistanceField.OccupancyRatio</td><td>Expected sparse global distacne field occupancy for the page atlas allocation. 0.25 means 25% - filled and 75% - empty.</td></tr><tr><td>r.AOGlobalDistanceFieldCacheMostlyStaticSeparately</td><td>Whether to cache mostly static primitives separately from movable primitives, which reduces global DF update cost when a movable primitive is modified. Adds another 12Mb of volume textures.</td></tr><tr><td>r.AOGlobalDistanceFieldClipmapUpdatesPerFrame</td><td>How many clipmaps to update each frame, only 1 or 2 supported. With values less than 2, the first clipmap is only updated every other frame, which can cause incorrect self occlusion during movement.</td></tr><tr><td>r.AOGlobalDistanceFieldDrawModifiedPrimitives</td><td>Whether to draw primitive modifications (add, remove, updatetransform) that caused an update of the global distance field.<br>This can be useful for tracking down why updating the global distance field is always costing a lot, since it should be mostly cached.</td></tr><tr><td>r.AOGlobalDistanceFieldForceFullUpdate</td><td>Whether to force full global distance field update every frame.</td></tr><tr><td>r.AOGlobalDistanceFieldForceMovementUpdate</td><td>Whether to force N texel border on X, Y and Z update each frame.</td></tr><tr><td>r.AOGlobalDistanceFieldLogModifiedPrimitives</td><td>Whether to log primitive modifications (add, remove, updatetransform) that caused an update of the global distance field.<br>This can be useful for tracking down why updating the global distance field is always costing a lot, since it should be mostly cached.<br>Pass 2 to log only non movable object updates.</td></tr><tr><td>r.AOGlobalDistanceFieldPartialUpdates</td><td>Whether to allow partial updates of the global distance field. When profiling it's useful to disable this and get the worst case composition time that happens on camera cuts.</td></tr><tr><td>r.AOGlobalDistanceFieldRepresentHeightfields</td><td>Whether to put landscape in the global distance field. Changing this won't propagate until the global distance field gets recached (fly away and back).</td></tr><tr><td>r.AOGlobalDistanceFieldStaggeredUpdates</td><td>Whether to allow the larger clipmaps to be updated less frequently.</td></tr><tr><td>r.AOHistoryDistanceThreshold</td><td>World space distance threshold needed to discard last frame's DFAO results. Lower values reduce ghosting from characters when near a wall but increase flickering artifacts.</td></tr><tr><td>r.AOHistoryStabilityPass</td><td>Whether to gather stable results to fill in holes in the temporal reprojection. Adds some GPU cost but improves temporal stability with foliage.</td></tr><tr><td>r.AOHistoryWeight</td><td>Amount of last frame's AO to lerp into the final result. Higher values increase stability, lower values have less streaking under occluder movement.</td></tr><tr><td>r.AOJitterConeDirections</td><td></td></tr><tr><td>r.AOListMemory</td><td></td></tr><tr><td>r.AOListMeshDistanceFields</td><td></td></tr><tr><td>r.AOMaxViewDistance</td><td>The maximum distance that AO will be computed at.</td></tr><tr><td>r.AOObjectDistanceField</td><td>Determines whether object distance fields are used to compute ambient occlusion.<br>Only global distance field will be used when this option is disabled.<br></td></tr><tr><td>r.AOOverwriteSceneColor</td><td></td></tr><tr><td>r.AOQuality</td><td>Defines the distance field AO method which allows to adjust for quality or performance.<br>0:off, 1:medium, 2:high (default)</td></tr><tr><td>r.AOSampleSet</td><td>0 = Original set, 1 = Relaxed set</td></tr><tr><td>r.AOScatterTileCulling</td><td>Whether to use the rasterizer for binning occluder objects into screenspace tiles.</td></tr><tr><td>r.AOSpecularOcclusionMode</td><td>Determines how specular should be occluded by DFAO<br>0: Apply non-directional AO to specular.<br>1: (default) Intersect the reflection cone with the unoccluded cone produced by DFAO. This gives more accurate occlusion than 0, but can bring out DFAO sampling artifacts.<br></td></tr><tr><td>r.AOStepExponentScale</td><td>Exponent used to distribute AO samples along a cone direction.</td></tr><tr><td>r.AOUpdateGlobalDistanceField</td><td>Whether to update the global distance field, useful for debugging.</td></tr><tr><td>r.AOUseHistory</td><td>Whether to apply a temporal filter to the distance field AO, which reduces flickering but also adds trails when occluders are moving.</td></tr><tr><td>r.AOUseJitter</td><td>Whether to use 4x temporal supersampling with Screen Grid DFAO. When jitter is disabled, a shorter history can be used but there will be more spatial aliasing.</td></tr><tr><td>r.AOViewFadeDistanceScale</td><td>Distance over which AO will fade out as it approaches r.AOMaxViewDistance, as a fraction of r.AOMaxViewDistance.</td></tr><tr><td>r.AsyncPipelineCompile</td><td>0 to Create PSOs at the moment they are requested<br>1 to Create Pipeline State Objects asynchronously(default)</td></tr><tr><td>r.BasePassForceOutputsVelocity</td><td>Force the base pass to compute motion vector, regardless of FPrimitiveUniformShaderParameters.0: Disabled (default)1: Enabled</td></tr><tr><td>r.BasePassOutputsVelocity</td><td>Deprecated CVar. Use r.VelocityOutputPass instead.<br></td></tr><tr><td>r.BasePassWriteDepthEvenWithFullPrepass</td><td>0 to allow a readonly base pass, which skips an MSAA depth resolve, and allows masked materials to get EarlyZ (writing to depth while doing clip() disables EarlyZ) (default)<br>1 to force depth writes in the base pass. Useful for debugging when the prepass and base pass don't match what they render.</td></tr><tr><td>r.bFlushRenderTargetsOnWorldCleanup</td><td></td></tr><tr><td>r.BlackBorders</td><td>To draw black borders around the rendered image<br>(prevents artifacts from post processing passes that read outside of the image e.g. PostProcessAA)<br>in pixels, 0:off</td></tr><tr><td>r.Bloom.AsyncCompute</td><td>Whether to run FFT bloom on async compute.<br></td></tr><tr><td>r.Bloom.CacheKernel</td><td>Whether to cache the kernel in spectral domain.</td></tr><tr><td>r.Bloom.ScreenPercentage</td><td>Controles the axis resolution of the FFT convolution for bloom.<br></td></tr><tr><td>r.BloomQuality</td><td>0: off, no performance impact.<br>1: average quality, least performance impact.<br>2: average quality, least performance impact.<br>3: good quality.<br>4: good quality.<br>5: Best quality, most significant performance impact. (default)<br>>5: force experimental higher quality on mobile (can be quite slow on some hardware)</td></tr><tr><td>r.BufferVisualizationDumpFrames</td><td>When screenshots or movies dumps are requested, also save out dumps of the current buffer visualization materials<br>0:off (default)<br>1:on</td></tr><tr><td>r.BufferVisualizationDumpFramesAsHDR</td><td>When saving out buffer visualization materials in a HDR capable format<br>0: Do not override default save format.<br>1: Force HDR format for buffer visualization materials.</td></tr><tr><td>r.BufferVisualizationOverviewTargets</td><td>Specify the list of post process materials that can be used in the buffer visualization overview. Put nothing between the commas to leave a gap.<br><br>Choose from:<br><br>BaseColor<br>CustomDepth<br>CustomStencil<br>FinalImage<br>ShadingModel<br>MaterialAO<br>Metallic<br>Opacity<br>Roughness<br>Anisotropy<br>SceneColor<br>SceneDepth<br>SeparateTranslucencyRGB<br>SeparateTranslucencyA<br>Specular<br>SubsurfaceColor<br>WorldNormal<br>WorldTangent<br>AmbientOcclusion<br>CustomDepthWorldUnits<br>SceneDepthWorldUnits<br>Velocity<br>PreTonemapHDRColor<br>PostTonemapHDRColor</td></tr><tr><td>r.BufferVisualizationTarget</td><td>When the viewport view-mode is set to 'Buffer Visualization', this command specifies which of the various channels to display. Values entered other than the allowed values shown below will be ignored.<br>BaseColor<br>CustomDepth<br>CustomStencil<br>FinalImage<br>ShadingModel<br>MaterialAO<br>Metallic<br>Opacity<br>Roughness<br>Anisotropy<br>SceneColor<br>SceneDepth<br>SeparateTranslucencyRGB<br>SeparateTranslucencyA<br>Specular<br>SubsurfaceColor<br>WorldNormal<br>WorldTangent<br>AmbientOcclusion<br>CustomDepthWorldUnits<br>SceneDepthWorldUnits<br>Velocity<br>PreTonemapHDRColor<br>PostTonemapHDRColor</td></tr><tr><td>r.Cache.DrawDirectionalShadowing</td><td>Whether to draw direct shadowing sample points as generated by Lightmass.<br>0 is off (default), 1 is on</td></tr><tr><td>r.Cache.DrawInterpolationPoints</td><td>Whether to draw positions that indirect lighting is interpolated at when they are updated, which are stored in the cache.<br>Probably need 'r.CacheUpdateEveryFrame 1' as well to be useful, otherwise points will flicker as they update.<br>0 is off (default), 1 is on</td></tr><tr><td>r.Cache.DrawLightingSamples</td><td>Whether to draw indirect lighting sample points as generated by Lightmass.<br>0 is off (default), 1 is on</td></tr><tr><td>r.Cache.LightingCacheDimension</td><td>Dimensions of the lighting cache. This should be a multiple of r.LightingCacheMovableObjectAllocationSize for least waste.</td></tr><tr><td>r.Cache.LightingCacheMovableObjectAllocationSize</td><td>Resolution of the interpolation sample volume used to light a dynamic object.<br>Values of 1 or 2 will result in a single interpolation sample per object which does not provide continuous lighting under movement, so interpolation is done over time.<br>Values of 3 or more support the necessary padding to provide continuous results under movement.</td></tr><tr><td>r.Cache.LimitQuerySize</td><td>0 is off, 1 is on (default)</td></tr><tr><td>r.Cache.QueryNodeLevel</td><td>Level of the lighting sample octree whose node's extents should be the target size for queries into the octree.<br>Primitive blocks will be broken up into multiple octree queries if they are larger than this.0 is the root, 12 is the leaf level</td></tr><tr><td>r.Cache.ReduceSHRinging</td><td>Whether to modify indirect lighting cache SH samples to reduce ringing. 0 is off, 1 is on (default)</td></tr><tr><td>r.Cache.SampleTransitionSpeed</td><td>When using single sample lighting, controls the speed of the transition between two point samples (fade over time).</td></tr><tr><td>r.Cache.UpdateEveryFrame</td><td>Whether to update indirect lighting cache allocations every frame, even if they would have been cached. 0 is off (default), 1 is on</td></tr><tr><td>r.Cache.UpdatePrimsTaskEnabled</td><td>Enable threading for ILC primitive update. Will overlap with the rest the end of InitViews.</td></tr><tr><td>r.CachedRayTracingInstances.CacheLocalTransform</td><td>Cache Local Transform instead of using InstanceData (increases memory usage).</td></tr><tr><td>r.CachedRayTracingInstances.LazyUpdate</td><td>Lazy update cached ray tracing instances world transforms.<br>Reduces memory usage by only caching world transforms of primitives when necessary.</td></tr><tr><td>r.CalcLocalPlayerCachedLODDistanceFactor</td><td>Should we calculate a LOD Distance Factor based on the current FOV. Should not be necessary since LOD is already based on screen size.<br></td></tr><tr><td>r.CameraCutTranslationThreshold</td><td>The maximum camera translation disatance in centimeters allowed between two frames before a camera cut is automatically inserted.</td></tr><tr><td>r.CapsuleDirectShadows</td><td>Whether to allow capsule direct shadowing on skinned components with bCastCapsuleDirectShadow enabled.</td></tr><tr><td>r.CapsuleIndirectConeAngle</td><td>Light source angle used when the indirect shadow direction is derived from precomputed indirect lighting (no stationary skylight present)</td></tr><tr><td>r.CapsuleIndirectShadows</td><td>Whether to allow capsule indirect shadowing on skinned components with bCastCapsuleIndirectShadow enabled.</td></tr><tr><td>r.CapsuleMaxDirectOcclusionDistance</td><td>Maximum cast distance for direct shadows from capsules. This has a big impact on performance.</td></tr><tr><td>r.CapsuleMaxIndirectOcclusionDistance</td><td>Maximum cast distance for indirect shadows from capsules. This has a big impact on performance.</td></tr><tr><td>r.CapsuleMinSkyAngle</td><td>Minimum light source angle derived from the precomputed unoccluded sky vector (stationary skylight present)</td></tr><tr><td>r.CapsuleShadowFadeAngleFromVertical</td><td>Angle from vertical up to start fading out the indirect shadow, to avoid self shadowing artifacts.</td></tr><tr><td>r.CapsuleShadows</td><td>Whether to allow capsule shadowing on skinned components with bCastCapsuleDirectShadow or bCastCapsuleIndirectShadow enabled.</td></tr><tr><td>r.CapsuleShadowsFullResolution</td><td>Whether to compute capsule shadows at full resolution.</td></tr><tr><td>r.CapsuleSkyAngleScale</td><td>Scales the light source angle derived from the precomputed unoccluded sky vector (stationary skylight present)</td></tr><tr><td>r.CatmullRomEndParamOffset</td><td>The parameter offset for catmul rom end points.</td></tr><tr><td>r.CEFGPUAcceleration</td><td>Enables GPU acceleration in CEF<br></td></tr><tr><td>r.chaos.ReflectionCaptureStaticSceneOnly</td><td>0 is off, 1 is on (default)</td></tr><tr><td>r.CheckSRVTransitions</td><td>Tests that render targets are properly transitioned to SRV when SRVs are set.</td></tr><tr><td>r.ClearCoatNormal</td><td>0 to disable clear coat normal.<br>0: off<br>1: on</td></tr><tr><td>r.ClearGBufferDBeforeBasePass</td><td>Whether to clear GBuffer D before basepass</td></tr><tr><td>r.ClearSceneMethod</td><td>Select how the g-buffer is cleared in game mode (only affects deferred shading).<br>0: No clear<br>1: RHIClear (default)<br>2: Quad at max z</td></tr><tr><td>r.Color.Grading</td><td>Controls whether post process settings's color grading settings should be applied.</td></tr><tr><td>r.Color.Max</td><td>Allows to define where the value 1.0 in the color channels is mapped to after color grading.<br>Value should be around 1, smaller values darken the highlights, larger values move more colors towards white, Default: 1</td></tr><tr><td>r.Color.Mid</td><td>Allows to define where the value 0.5 in the color channels is mapped to after color grading (This is similar to a gamma correction).<br>Value should be around 0.5, smaller values darken the mid tones, larger values brighten the mid tones, Default: 0.5</td></tr><tr><td>r.Color.Min</td><td>Allows to define where the value 0 in the color channels is mapped to after color grading.<br>The value should be around 0, positive: a gray scale is added to the darks, negative: more dark values become black, Default: 0</td></tr><tr><td>r.CompileMaterialsForShaderFormat</td><td>When enabled, compile materials for this shader format in addition to those for the running platform.<br>Note that these shaders are compiled and immediately tossed. This is only useful when directly inspecting output via r.DebugDumpShaderInfo.</td></tr><tr><td>r.CompileShadersForDevelopment</td><td>Setting this to 0 allows to ship a game with more optimized shaders as some<br>editor and development features are not longer compiled into the shaders.<br>Note: This should be done when shipping but it's not done automatically yet (feature need to mature<br>and shaders will compile slower as shader caching from development isn't shared).<br>Cannot be changed at runtime - can be put into BaseEngine.ini<br>0: off, shader can run a bit faster<br>1: on (Default)</td></tr><tr><td>r.ContactShadows</td><td>0: disabled.<br>1: enabled.<br></td></tr><tr><td>r.ContactShadows.NonShadowCastingIntensity</td><td>Intensity of contact shadows from objects with cast contact shadows disabled. Usually 0 (off).<br></td></tr><tr><td>r.CookOutUnusedDetailModeComponents</td><td>If set, components which are not relevant for the current detail mode will be cooked out.<br>0: keep components even if not relevant for the current detail mode.<br>1: cook out components not relevant for the current detail mode.<br></td></tr><tr><td>r.CopyLockedViews</td><td>Copies all locked views in to a string that r.LockView will accept to reload them.</td></tr><tr><td>r.CreateShadersOnLoad</td><td>Whether to create shaders on load, which can reduce hitching, but use more memory. Otherwise they will be created as needed.</td></tr><tr><td>r.CullInstances</td><td>CullInstances.</td></tr><tr><td>r.CustomDepth</td><td>0: feature is disabled<br>1: feature is enabled, texture is created on demand<br>2: feature is enabled, texture is not released until required (should be the project setting if the feature should not stall)<br>3: feature is enabled, stencil writes are enabled, texture is not released until required (should be the project setting if the feature should not stall)</td></tr><tr><td>r.CustomDepth.Order</td><td>When CustomDepth (and CustomStencil) is getting rendered<br>0: Before Base Pass (Allows samping in DBuffer pass. Can be more efficient with AsyncCompute.)<br>1: After Base Pass<br>2: Default (Before Base Pass if DBuffer enabled.)<br></td></tr><tr><td>r.CustomDepthTemporalAAJitter</td><td>If disabled the Engine will remove the TemporalAA Jitter from the Custom Depth Pass. Only has effect when TemporalAA is used.</td></tr><tr><td>r.CustomUnsafeZones</td><td>Allows you to set custom unsafe zones. Define them based on Portrait (P) or Landscape (L) for a device oriented 'upright'.Unsafe zones may be either fixed or free, depending on if they move along with the rotation of the device.Format is (P:fixed[x1, y1][width, height]), semicolon-separated for each custom unsafe zone. +Values add from 0, -Values subtract from Height or Width</td></tr><tr><td>r.D3D.CheckedForTypedUAVs</td><td>Whether to disallow usage of typed UAV loads, as they are unavailable in Windows 7 D3D 11.0.<br>0: Allow usage of typed UAV loads.<br>1: Disallow usage of typed UAV loads. (default)</td></tr><tr><td>r.D3D.ForceDXC</td><td>Forces DirectX Shader Compiler (DXC) to be used for all D3D shaders. Shaders compiled with this option are only compatible with D3D12.<br>0: Disable (default)<br>1: Force new compiler for all shaders</td></tr><tr><td>r.D3D.ForceShaderConductorDXCRewrite</td><td>Forces rewriting using ShaderConductor when DXC is enabled.<br>0: Do not rewrite (default)<br>1: Force ShaderConductor rewrite</td></tr><tr><td>r.D3D.RemoveUnusedInterpolators</td><td>Enables removing unused interpolators mode when compiling pipelines for D3D.<br>-1: Do not actually remove, but make the app think it did (for debugging)<br>0: Disable (default)<br>1: Enable removing unused</td></tr><tr><td>r.D3D12.AllowAsyncCompute</td><td>Allow usage of async compute</td></tr><tr><td>r.D3D12.AllowShaderModel6</td><td>Allows the usage of SM6 feature level.</td></tr><tr><td>r.D3D12.AutoAttachPIX</td><td>Automatically attach PIX on startup</td></tr><tr><td>r.D3D12.BreadCrumbs</td><td>Enable minimal overhead GPU Breadcrumbs to track the current GPU state and logs information what operations the GPU executed last.<br></td></tr><tr><td>r.D3D12.Depth24Bit</td><td>0: Use 32-bit float depth buffer<br>1: Use 24-bit fixed point depth buffer(default)<br></td></tr><tr><td>r.D3D12.DRED</td><td>Enable DRED GPU Crash debugging mode to track the current GPU state and logs information what operations the GPU executed last.Has GPU overhead but gives the most information on the current GPU state when it crashes or hangs.<br></td></tr><tr><td>r.D3D12.DXR.MinimumDriverVersionAMD</td><td>Sets the minimum driver version required to enable ray tracing on AMD GPUs.</td></tr><tr><td>r.D3D12.DXR.MinimumDriverVersionNVIDIA</td><td>Sets the minimum driver version required to enable ray tracing on NVIDIA GPUs.</td></tr><tr><td>r.D3D12.DXR.MinimumWindowsBuildVersion</td><td>Sets the minimum Windows build version required to enable ray tracing.</td></tr><tr><td>r.D3D12.ExecuteCommandListTask</td><td>0: Execute command lists on RHI Thread instead of separate task!<br>1: Execute command lists on task created from RHIThread to offload expensive work (default)<br></td></tr><tr><td>r.D3D12.ExperimentalShaderModels</td><td>Controls whether D3D12 experimental shader models should be allowed. Not available in shipping builds. (default = 0).</td></tr><tr><td>r.D3D12.GPUTimeout</td><td>0: Disable GPU Timeout; use with care as it could freeze your PC!<br>1: Enable GPU Timeout; operation taking long on the GPU will fail(default)<br></td></tr><tr><td>r.D3D12.NvAfterMath</td><td>Enable NvAftermath to track the current GPU state and logs information what operations the GPU executed last.<br>Only works on nVidia hardware and will dump GPU crashdumps as well.<br></td></tr><tr><td>r.D3D12.RayTracing.AllowCompaction</td><td>Whether to automatically perform compaction for static acceleration structures to save GPU memory. (default = 1)<br></td></tr><tr><td>r.D3D12.RayTracing.AllowSpecializedStateObjects</td><td>Whether to use specialized RTPSOs if they have been created. This is intended for performance testingand has no effect if r.D3D12.RayTracing.SpecializeStateObjects is 0. (default = 1)<br></td></tr><tr><td>r.D3D12.RayTracing.CacheShaderRecords</td><td>Automatically cache and re-use SBT hit group records. This significantly improves CPU performance in large scenes with many identical mesh instances. (default = 1)<br>This mode assumes that contents of uniform buffers does not change during ray tracing resource binding.</td></tr><tr><td>r.D3D12.RayTracing.DebugForceBuildMode</td><td>Forces specific acceleration structure build mode (not runtime-tweakable).<br>0: Use build mode requested by high-level code (Default)<br>1: Force fast build mode<br>2: Force fast trace mode<br></td></tr><tr><td>r.D3D12.RayTracing.DeduplicateSamplers</td><td>Use an exhaustive search to deduplicate sampler descriptors when generating shader binding tables. Reduces sampler heap usage at the cost of some CPU time. (default = 1)</td></tr><tr><td>r.D3D12.RayTracing.MaxBatchedCompaction</td><td>Maximum of amount of compaction requests and rebuilds per frame. (default = 64)<br></td></tr><tr><td>r.D3D12.RayTracing.SpecializeStateObjects</td><td>Whether to create specialized unique ray tracing pipeline state objects for each ray generation shader. (default = 0)<br>This option can produce more more efficient PSOs for the GPU at the cost of longer creation times and more memory. Requires DXR 1.1.<br></td></tr><tr><td>r.D3D12.RayTracing.ViewDescriptorHeapSize</td><td>Maximum number of descriptors per ray tracing view descriptor heap. (default = 250k, ~8MB per heap)<br>Typical measured descriptor heap usage in large scenes is ~50k. An error is reported when this limit is reached and shader bindings for subsequent objects are skipped.<br></td></tr><tr><td>r.D3D12.UseAllowTearing</td><td>Enable new dxgi flip mode with d3d12</td></tr><tr><td>r.D3D12.UseInternalTransitions</td><td>Use the D3D12 RHI internal transitions to drive all resource transitions</td></tr><tr><td>r.D3D12.ValidateInternalTransitions</td><td>Use the D3D12 RHI internal transitions to validate the engine pushed RHI transitions</td></tr><tr><td>r.DBuffer</td><td>Enables DBuffer decal material blend modes.<br>DBuffer decals are rendered before the base pass, allowing them to affect static lighting and skylighting correctly.<br>When enabled, a full prepass will be forced which adds CPU / GPU cost. Several texture lookups will be done in the base pass to fetch the decal properties, which adds pixel work.<br>0: off<br>1: on (default)</td></tr><tr><td>r.DebugActionZone.ActionRatio</td><td>The action zone ratio that will be returned by FDisplayMetrics::GetDisplayMetrics on platforms that don't have a defined safe zone (0..1)<br>default: 1.0</td></tr><tr><td>r.DebugLightDiscardProp</td><td>[0,1]: Proportion of lights to discard for debug/performance profiling purposes.</td></tr><tr><td>r.DebugSafeZone.MaxDebugTextStringsPerActor</td><td>The maximum number of debug strings that can be attached to a given actor (&#x3C;=0 : no limit)</td></tr><tr><td>r.DebugSafeZone.Mode</td><td>The safe zone visualization mode (0..2)<br>0: Disabled (default)<br>1: Show Title Safe Zone<br>2: Show Action Safe Zone</td></tr><tr><td>r.DebugSafeZone.OverlayAlpha</td><td>The alpha value of the safe zone overlay (0..1)<br>default: 0.2</td></tr><tr><td>r.DebugSafeZone.TitleRatio</td><td>The safe zone ratio that will be returned by FDisplayMetrics::GetDisplayMetrics on platforms that don't have a defined safe zone (0..1)<br>default: 1.0</td></tr><tr><td>r.Decal.FadeDurationScale</td><td>Scales the per decal fade durations. Lower values shortens lifetime and fade duration. Default is 1.0f.</td></tr><tr><td>r.Decal.FadeScreenSizeMult</td><td>Control the per decal fade screen size. Multiplies with the per-decal screen size fade threshold. Smaller means decals fade less aggressively.</td></tr><tr><td>r.Decal.NormalReprojectionEnabled</td><td>If true, normal reprojection from the previous frame is allowed in SceneTexture nodes on DBuffer decals, provided that motion in depth prepass is enabled as well (r.VelocityOutputPass=0). Otherwise the fallback is the normal extracted from the depth buffer.</td></tr><tr><td>r.Decal.NormalReprojectionThresholdHigh</td><td>When reading the normal from a SceneTexture node in a DBuffer decal shader, the normal is a mix of the geometry normal (extracted from the depth buffer) and the normal from the reprojected previous frame. When the dot product of the geometry and reprojected normal is below the r.Decal.NormalReprojectionThresholdLow, the geometry normal is used. When that value is above r.Decal.NormalReprojectionThresholdHigh, the reprojected normal is used. Otherwise it uses a lerp between them.</td></tr><tr><td>r.Decal.NormalReprojectionThresholdLow</td><td>When reading the normal from a SceneTexture node in a DBuffer decal shader, the normal is a mix of the geometry normal (extracted from the depth buffer) and the normal from the reprojected previous frame. When the dot product of the geometry and reprojected normal is below the r.Decal.NormalReprojectionThresholdLow, the geometry normal is used. When that value is above r.Decal.NormalReprojectionThresholdHigh, the reprojected normal is used. Otherwise it uses a lerp between them.</td></tr><tr><td>r.Decal.StencilSizeThreshold</td><td>Control a per decal stencil pass that allows to large (screen space) decals faster. It adds more overhead per decals so this<br>&#x3C;0: optimization is disabled<br>0: optimization is enabled no matter how small (screen space) the decal is<br>0..1: optimization is enabled, value defines the minimum size (screen space) to trigger the optimization (default 0.1)</td></tr><tr><td>r.DecalDepthBias</td><td>Global depth bias used by mesh decals. Default is 0.005</td></tr><tr><td>r.DefaultBackBufferPixelFormat</td><td>Defines the default back buffer pixel format.<br>0: 8bit RGBA<br>1: 16bit RGBA<br>2: Float RGB<br>3: Float RGBA<br>4: 10bit RGB, 2bit Alpha<br></td></tr><tr><td>r.DefaultFeature.AmbientOcclusion</td><td>Engine default (project setting) for AmbientOcclusion is (postprocess volume/camera/game setting still can override)<br>0: off, sets AmbientOcclusionIntensity to 0<br>1: on (default)</td></tr><tr><td>r.DefaultFeature.AmbientOcclusionStaticFraction</td><td>Engine default (project setting) for AmbientOcclusion is (postprocess volume/camera/game setting still can override)<br>0: off, sets AmbientOcclusionStaticFraction to 0<br>1: on (default, costs extra pass, only useful if there is some baked lighting)</td></tr><tr><td>r.DefaultFeature.AutoExposure</td><td>Engine default (project setting) for AutoExposure is (postprocess volume/camera/game setting still can override)<br>0: off, sets AutoExposureMinBrightness and AutoExposureMaxBrightness to 1<br>1: on (default)</td></tr><tr><td>r.DefaultFeature.AutoExposure.Bias</td><td>Engine default (project setting) for AutoExposure Exposure Bias (postprocess volume/camera/game setting still can override)<br></td></tr><tr><td>r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange</td><td>Whether the default values for AutoExposure should support an extended range of scene luminance.<br>This also change the PostProcessSettings.Exposure.MinBrightness, MaxBrightness, HistogramLogMin and HisogramLogMax<br>to be expressed in EV100 values instead of in Luminance and Log2 Luminance.<br>0: Legacy range (default)<br>1: Extended range</td></tr><tr><td>r.DefaultFeature.AutoExposure.Method</td><td>Engine default (project setting) for AutoExposure Method (postprocess volume/camera/game setting still can override)<br>0: Histogram based (requires compute shader, default)<br>1: Basic AutoExposure</td></tr><tr><td>r.DefaultFeature.Bloom</td><td>Engine default (project setting) for Bloom is (postprocess volume/camera/game setting still can override)<br>0: off, set BloomIntensity to 0<br>1: on (default)</td></tr><tr><td>r.DefaultFeature.LensFlare</td><td>Engine default (project setting) for LensFlare is (postprocess volume/camera/game setting still can override)<br>0: off, sets LensFlareIntensity to 0<br>1: on (default)</td></tr><tr><td>r.DefaultFeature.LightUnits</td><td>Default units to use for point, spot and rect lights<br>0: unitless<br>1: candelas (default)<br>2: lumens</td></tr><tr><td>r.DefaultFeature.MotionBlur</td><td>Engine default (project setting) for MotionBlur is (postprocess volume/camera/game setting still can override)<br>0: off, sets MotionBlurAmount to 0<br>1: on (default)</td></tr><tr><td>r.DeferSkeletalDynamicDataUpdateUntilGDME</td><td>If > 0, then do skeletal mesh dynamic data updates will be deferred until GDME. Experimental option.</td></tr><tr><td>r.DeferUniformExpressionCaching</td><td>Whether to defer caching of uniform expressions until a rendering command needs them up to date. Deferring updates is more efficient because multiple SetVectorParameterValue calls in a frame will only result in one update.</td></tr><tr><td>r.DeferUpdateRenderStates</td><td>Whether to defer updating the render states of material parameter collections when a paramter is changed until a rendering command needs them up to date. Deferring updates is more efficient because multiple SetVectorParameterValue and SetScalarParameterValue calls in a frame will only result in one update.</td></tr><tr><td>r.DemosaicVposOffset</td><td>This offset is added to the rasterized position used for demosaic in the mobile tonemapping shader. It exists to workaround driver bugs on some Android devices that have a half-pixel offset.</td></tr><tr><td>r.DemotedLocalMemoryWarning</td><td>If set to 1, a warning will be displayed when local memory has been demoted to system memory.</td></tr><tr><td>r.DepthOfField.DepthBlur.Amount</td><td>This scale multiplier only affects the CircleDOF DepthBlur feature (value defines in how many km the radius goes to 50%).<br>x: Multiply the existing Depth Blur Amount with x<br>-x: Override the existing Depth Blur Amount with x (in km)<br>1: No adjustments (default)</td></tr><tr><td>r.DepthOfField.DepthBlur.ResolutionScale</td><td>This scale multiplier only affects the CircleDOF DepthBlur feature. It's a temporary hack.<br>It lineary scale the DepthBlur by the resolution increase over 1920 (in width), does only affect resolution larger than that.<br>Actual math: float Factor = max(ViewWidth / 1920 - 1, 0); DepthBlurRadius *= 1 + Factor * (CVar - 1)<br>1: No adjustments (default)<br>x: if the resolution is 1920 there is no change, if 2x larger than 1920 it scale the radius by x</td></tr><tr><td>r.DepthOfField.DepthBlur.Scale</td><td>This scale multiplier only affects the CircleDOF DepthBlur feature. This is applied after r.DepthOfField.DepthBlur.ResolutionScale.<br>0: Disable Depth Blur<br>x: Multiply the existing Depth Blur Radius with x<br>-x: Override the existing Depth Blur Radius with x<br>1: No adjustments (default)</td></tr><tr><td>r.DepthOfField.MaxSize</td><td>Allows to clamp the gaussian depth of field radius (for better performance), default: 100</td></tr><tr><td>r.DepthOfField.NearBlurSizeThreshold</td><td>Sets the minimum near blur size before the effect is forcably disabled. Currently only affects Gaussian DOF.<br>(default: 0.01)</td></tr><tr><td>r.DepthOfFieldQuality</td><td>Allows to adjust the depth of field quality. Currently only fully affects BokehDOF. GaussianDOF is either 0 for off, otherwise on.<br>0: Off<br>1: Low<br>2: high quality (default, adaptive, can be 4x slower)<br>3: very high quality, intended for non realtime cutscenes, CircleDOF only (slow)<br>4: extremely high quality, intended for non realtime cutscenes, CircleDOF only (very slow)</td></tr><tr><td>r.DetailMode</td><td>Current detail mode; determines whether components of actors should be updated/ ticked.<br>0: low, show only object with DetailMode low or higher<br>1: medium, show all object with DetailMode medium or higher<br>2: high, show all objects (default)</td></tr><tr><td>r.DFDistanceScale</td><td>Factor to scale directional light property 'DistanceField Shadows Distance', clamped to [0.0001, 10000].<br>I.e.: DistanceFieldShadowsDistance *= r.DFDistanceScale.<br>[0.0001,1): shorter distance<br>1: normal (default)<br>(1,10000]: larger distance.)</td></tr><tr><td>r.DFFarTransitionScale</td><td>Use to modify the length of the far transition (fade out) of the distance field shadows.<br>1.0: (default) Calculate in the same way as other cascades.0.0: Disable fade out.</td></tr><tr><td>r.DFFullResolution</td><td>1 = full resolution distance field shadowing, 0 = half resolution with bilateral upsample.</td></tr><tr><td>r.DFShadowAsyncCompute</td><td>Whether render distance field shadows using async compute if possible</td></tr><tr><td>r.DFShadowAverageObjectsPerCullTile</td><td>Determines how much memory should be allocated in distance field object culling data structures. Too much = memory waste, too little = flickering due to buffer overflow.</td></tr><tr><td>r.DFShadowCompactCulledObjects</td><td>Whether to compact culled object indices when using scattered tile culling. Note that each tile can only hold up to r.DFShadowAverageObjectsPerCullTile number of objects when compaction is not used.</td></tr><tr><td>r.DFShadowCullTileWorldSize</td><td>World space size of a tile used for culling for directional lights.</td></tr><tr><td>r.DFShadowOffsetDataStructure</td><td>Which data structure to store offset in, 0 - base, 1 - buffer, 2 - texture</td></tr><tr><td>r.DFShadowQuality</td><td>Defines the distance field shadow method which allows to adjust for quality or performance.<br>0:off, 1:low (20 steps, no SSS), 2:medium (32 steps, no SSS), 3:high (64 steps, SSS, default)</td></tr><tr><td>r.DFShadowScatterTileCulling</td><td>Whether to use the rasterizer to scatter objects onto the tile grid for culling.</td></tr><tr><td>r.DFTwoSidedMeshDistanceBias</td><td>World space amount to expand distance field representations of two sided meshes. This is useful to get tree shadows to match up with standard shadow mapping.</td></tr><tr><td>r.DiffuseColor.Max</td><td>Allows quick material test by remapping the diffuse color at 1 to a new value (0..1), Only for non shipping built!<br>1: (default)</td></tr><tr><td>r.DiffuseColor.Min</td><td>Allows quick material test by remapping the diffuse color at 1 to a new value (0..1), Only for non shipping built!<br>1: (default)</td></tr><tr><td>r.DiffuseIndirect.Denoiser</td><td>Denoising options (default = 1)</td></tr><tr><td>r.DiffuseIndirect.HalfRes</td><td>TODO(Guillaume)</td></tr><tr><td>r.DiffuseIndirect.RayPerPixel</td><td>TODO(Guillaume)</td></tr><tr><td>r.DisableDistortion</td><td>Prevents distortion effects from rendering. Saves a full-screen framebuffer's worth of memory.</td></tr><tr><td>r.DisableDriverWarningPopupIfGFN</td><td>If non-zero, disable driver version warning popup if running on a GFN cloud machine.</td></tr><tr><td>r.DisableEngineAndAppRegistration</td><td>If true, disables engine and app registration, to disable GPU driver optimizations during debugging and development<br>Changes will only take effect in new game/editor instances - can't be changed at runtime.<br></td></tr><tr><td>r.DisableLODFade</td><td>Disable fading for distance culling</td></tr><tr><td>r.DiscardUnusedQuality</td><td>Whether to keep or discard unused quality level shadermaps in memory.<br>0: keep all quality levels in memory. (default)<br>1: Discard unused quality levels on load.</td></tr><tr><td>r.DisplayInternals</td><td>Allows to enable screen printouts that show the internals on the engine/renderer<br>This is mostly useful to be able to reason why a screenshots looks different.<br>0: off (default)<br>1: enabled</td></tr><tr><td>r.DistanceFadeMaxTravel</td><td>Max distance that the player can travel during the fade time.</td></tr><tr><td>r.DistanceFieldAO</td><td>Whether the distance field AO feature is allowed, which is used to implement shadows of Movable sky lights from static meshes.</td></tr><tr><td>r.DistanceFieldAO.TraverseMips</td><td>Whether to traverse mips while tracing AO cones against object SDFs.</td></tr><tr><td>r.DistanceFields</td><td>Enables distance fields rendering.<br>0: Disabled.<br>1: Enabled.</td></tr><tr><td>r.DistanceFields.BlockAllocatorSizeInBricks</td><td>Allocation granularity of the distance field block allocator. Higher number may cause more memory wasted on padding but allocation may be faster.</td></tr><tr><td>r.DistanceFields.BrickAtlasMaxSizeZ</td><td>Target for maximum depth of the Mesh Distance Field atlas, in 8^3 bricks. 32 => 128 * 128 * 32 * 8^3 = 256Mb. Actual atlas size can go over since mip2 is always loaded.</td></tr><tr><td>r.DistanceFields.BrickAtlasSizeXYInBricks</td><td>Controls the allocation granularity of the atlas, which grows in Z.</td></tr><tr><td>r.DistanceFields.Debug.ForceNumMips</td><td>When set to > 0, overrides the requested number of mips for streaming. 1 = only lowest resolution mip loaded, 3 = all mips loaded. Mips will still be clamped by available space in the atlas.</td></tr><tr><td>r.DistanceFields.Debug.ResizeAtlasEveryFrame</td><td>Whether to resize the Distance Field atlas every frame, which is useful for debugging.</td></tr><tr><td>r.DistanceFields.DefaultVoxelDensity</td><td>Determines how the default scale of a mesh converts into distance field voxel dimensions.<br>Changing this will cause all distance fields to be rebuilt. Large values can consume memory very quickly!</td></tr><tr><td>r.DistanceFields.DefragmentIndirectionAtlas</td><td>Whether to defragment the Distance Field indirection atlas when it requires resizing.</td></tr><tr><td>r.DistanceFields.LogAtlasStats</td><td>Set to 1 to dump atlas stats, set to 2 to dump atlas and SDF asset stats.</td></tr><tr><td>r.DistanceFields.MaxIndirectionAtlasSizeXYZ</td><td>Maximum size of indirection atlas texture</td></tr><tr><td>r.DistanceFields.MaxObjectBoundingRadius</td><td>Objects larger than this will not be included in the Mesh Distance Field scene, to improve performance.</td></tr><tr><td>r.DistanceFields.MaxPerMeshResolution</td><td>Highest resolution (in one dimension) allowed for a single static mesh asset, used to cap the memory usage of meshes with a large scale.<br>Changing this will cause all distance fields to be rebuilt. Large values such as 512 can consume memory very quickly! (64Mb for one asset at 512)</td></tr><tr><td>r.DistanceFields.MinIndirectionAtlasSizeXYZ</td><td>Minimum size of indirection atlas texture</td></tr><tr><td>r.DistanceFields.ParallelUpdate</td><td></td></tr><tr><td>r.DistanceFields.ReverseAtlasAllocationOrder</td><td></td></tr><tr><td>r.DistanceFields.SupportEvenIfHardwareRayTracingSupported</td><td>Whether to support distance fields when hardware ray tracing is supported.<br>Setting it to 0 will skip distance field overhead when hardware ray tracing is supported.</td></tr><tr><td>r.DistanceFields.SurfaceBiasExpand</td><td>Fraction of a Mesh SDF voxel to expand the surface during intersection. Expanding the surface improves representation quality, at the cost of over-occlusion.</td></tr><tr><td>r.DistanceFields.TextureUploadLimitKBytes</td><td>Max KB of distance field texture data to upload per frame from streaming requests.</td></tr><tr><td>r.DistanceFields.TwoSidedSurfaceBiasExpand</td><td>Amount to scale the surface bias for meshes with mostly two sided triangles. Two sided meshes are not represented well with Signed Distance Fields, as no negative region gets created. Expanding the surface improves representation quality, at the cost of over-occlusion.</td></tr><tr><td>r.DistanceFieldShadowing</td><td>Whether the distance field shadowing feature is allowed.</td></tr><tr><td>r.DOF.Gather.AccumulatorQuality</td><td>Controles the quality of the gathering accumulator.<br></td></tr><tr><td>r.DOF.Gather.EnableBokehSettings</td><td>Whether to applies bokeh settings on foreground and background gathering.<br>0: Disable;<br>1: Enable (default).</td></tr><tr><td>r.DOF.Gather.PostfilterMethod</td><td>Method to use to post filter a gather pass.<br>0: None;<br>1: Per RGB channel median 3x3 (default);<br>2: Per RGB channel max 3x3.</td></tr><tr><td>r.DOF.Gather.RingCount</td><td>Number of rings for gathering kernels [[3; 5]]. Default to 5.<br></td></tr><tr><td>r.DOF.Kernel.MaxBackgroundRadius</td><td>Maximum size of the background bluring radius in screen space (default=0.025).</td></tr><tr><td>r.DOF.Kernel.MaxForegroundRadius</td><td>Maximum size of the foreground bluring radius in screen space (default=0.025).</td></tr><tr><td>r.DOF.Recombine.EnableBokehSettings</td><td>Whether to applies bokeh settings on slight out of focus done in recombine pass.<br>0: Disable;<br>1: Enable (default).</td></tr><tr><td>r.DOF.Recombine.MinFullresBlurRadius</td><td>Minimal blurring radius used in full resolution pixel width to actually do DOF when slight out of focus is enabled (default = 0.1).</td></tr><tr><td>r.DOF.Recombine.Quality</td><td>Configures the quality of the recombine pass.<br>0: No slight out of focus;<br>1: Slight out of focus 24spp;<br>2: Slight out of focus 32spp (default).</td></tr><tr><td>r.DOF.Scatter.BackgroundCompositing</td><td>Compositing mode of the background hybrid scattering.<br>0: Disabled;<br>1: Additive;<br>2: Gather occlusion (default).</td></tr><tr><td>r.DOF.Scatter.EnableBokehSettings</td><td>Whether to enable bokeh settings on scattering.<br>0: Disable;<br>1: Enable (default).</td></tr><tr><td>r.DOF.Scatter.ForegroundCompositing</td><td>Compositing mode of the foreground hybrid scattering.<br>0: Disabled;<br>1: Additive (default).</td></tr><tr><td>r.DOF.Scatter.MaxSpriteRatio</td><td>Maximum ratio of scattered pixel quad as sprite, usefull to control DOF's scattering upperbound. 1 will allow to scatter 100% pixel quads, whereas 0.2 will only allow 20% (default = 0.1).</td></tr><tr><td>r.DOF.Scatter.MinCocRadius</td><td>Minimal Coc radius required to be scattered (default = 3).</td></tr><tr><td>r.DOF.Scatter.NeighborCompareMaxColor</td><td>Controles the linear color clamping upperbound applied before color of pixel and neighbors are compared. To low, and you may not scatter enough; to high you may scatter unnecessarily too much in highlights (Default: 10).</td></tr><tr><td>r.DOF.TemporalAAQuality</td><td>Quality of temporal AA pass done in DOF.<br>0: Faster but lower quality; 1: Higher quality pass (default).</td></tr><tr><td>r.DoLazyStaticMeshUpdate</td><td>If true, then do not add meshes to the static mesh draw lists until they are visible. Experiemental option.</td></tr><tr><td>r.DontLimitOnBattery</td><td>0: Limit performance on devices with a battery.(default)<br>1: Do not limit performance due to device having a battery.</td></tr><tr><td>r.DoTiledReflections</td><td>Compute Reflection Environment with Tiled compute shader..<br>0: off<br>1: on (default)</td></tr><tr><td>r.DownsampledOcclusionQueries</td><td>Whether to issue occlusion queries to a downsampled depth buffer</td></tr><tr><td>r.DrawRectangleOptimization</td><td>Controls an optimization for DrawRectangle(). When enabled a triangle can be used to draw a quad in certain situations (viewport sized quad).<br>Using a triangle allows for slightly faster post processing in lower resolutions but can not always be used.<br>0: Optimization is disabled, DrawDenormalizedQuad always render with quad<br>1: Optimization is enabled, a triangle can be rendered where specified (default)</td></tr><tr><td>r.DriverDetectionMethod</td><td>Defines which implementation is used to detect the GPU driver (to check for old drivers, logs and statistics)<br>0: Iterate available drivers in registry and choose the one with the same name, if in question use next method (happens)<br>1: Get the driver of the primary adapter (might not be correct when dealing with multiple adapters)<br>2: Use DirectX LUID (would be the best, not yet implemented)<br>3: Use Windows functions, use the primary device (might be wrong when API is using another adapter)<br>4: Use Windows functions, use names such as DirectX Device (newest, most promising)</td></tr><tr><td>r.DumpGPU.Buffer</td><td>Whether to dump buffer.<br>0: Ignores all buffers<br>1: Dump only buffers' descriptors<br>2: Dump buffers' descriptors and binaries (default)</td></tr><tr><td>r.DumpGPU.ConsoleVariables</td><td>Whether to dump rendering console variables (enabled by default).</td></tr><tr><td>r.DumpGPU.Directory</td><td>Directory to dump to.</td></tr><tr><td>r.DumpGPU.Draws</td><td>Whether to dump resource after each individual draw call (disabled by default).</td></tr><tr><td>r.DumpGPU.Explore</td><td>Whether to open file explorer to where the GPU dump on completion (enabled by default).</td></tr><tr><td>r.DumpGPU.Mask</td><td>Whether to include GPU mask in the name of each Pass (has no effect unless system has multiple GPUs).</td></tr><tr><td>r.DumpGPU.PassParameters</td><td>Whether to dump the pass parameters.</td></tr><tr><td>r.DumpGPU.Root</td><td>Allows to filter the tree when using r.DumpGPU command, the pattern match is case sensitive.</td></tr><tr><td>r.DumpGPU.Screenshot</td><td>Whether to take a final screenshot.</td></tr><tr><td>r.DumpGPU.Test.EnableDiskWrite</td><td>Master switch whether any files should be written to disk, used for r.DumpGPU automation tests to not fill up workers' hard drive.</td></tr><tr><td>r.DumpGPU.Test.PrettifyResourceFileNames</td><td>Whether the resource file names should include resource name. May increase the likelyness of running into Windows' filepath limit.</td></tr><tr><td>r.DumpGPU.Texture</td><td>Whether to dump textures.<br>0: Ignores all textures<br>1: Dump only textures' descriptors<br>2: Dump textures' descriptors and binaries (default)</td></tr><tr><td>r.DumpGPU.Viewer.Visualize</td><td>Name of RDG output resource to automatically open in the dump viewer.</td></tr><tr><td>r.DumpingMovie</td><td>Allows to dump each rendered frame to disk (slow fps, names MovieFrame..).<br>&#x3C;=0:off (default), &#x3C;0:remains on, >0:remains on for n frames (n is the number specified)</td></tr><tr><td>r.DumpPipelineCache</td><td>Dump current cache stats.</td></tr><tr><td>r.DumpRenderTargetPoolMemory</td><td>Dump allocation information for the render target pool.</td></tr><tr><td>r.DumpShaderDebugInfo</td><td>Dumps debug info for compiled shaders to GameName/Saved/ShaderDebugInfo<br>When set to 1, debug info is dumped for all compiled shader<br>When set to 2, it is restricted to shaders with compilation errors<br>When set to 3, it is restricted to shaders with compilation errors or warnings<br>The debug info is platform dependent, but usually includes a preprocessed version of the shader source.<br>Global shaders automatically dump debug info if r.ShaderDevelopmentMode is enabled, this cvar is not necessary.<br>On iOS, if the PowerVR graphics SDK is installed to the default path, the PowerVR shader compiler will be called and errors will be reported during the cook.</td></tr><tr><td>r.DumpShaderDebugShortNames</td><td>Only valid when r.DumpShaderDebugInfo > 0.<br>When set to 1, will shorten names factory and shader type folder names to avoid issues with long paths.</td></tr><tr><td>r.DumpShaderDebugWorkerCommandLine</td><td>Only valid when r.DumpShaderDebugInfo > 0.<br>When set to 1, it will generate a file that can be used with ShaderCompileWorker's -directcompile.</td></tr><tr><td>r.DumpShadows</td><td>Dump shadow setup (for developer only, only for non shiping build)</td></tr><tr><td>r.DumpTransitionsForResource</td><td>Prints callstack when the given resource is transitioned. Only implemented for DX11 at the moment.Name of the resource to dump</td></tr><tr><td>r.DX12NVAfterMathEnabled</td><td>Use NV Aftermath for GPU crash analysis in D3D12</td></tr><tr><td>r.DX12NVAfterMathTrackResources</td><td>Enable NV Aftermath resource tracing in D3D12</td></tr><tr><td>r.DynamicGlobalIlluminationMethod</td><td>0 - None. Global Illumination can be baked into Lightmaps but no technique will be used for Dynamic Global Illumination.<br>1 - Lumen. Use Lumen Global Illumination for all lights, emissive materials casting light and SkyLight Occlusion. Requires 'Generate Mesh Distance Fields' enabled for Software Ray Tracing and 'Support Hardware Ray Tracing' enabled for Hardware Ray Tracing.<br>2 - SSGI. Standalone Screen Space Global Illumination. Low cost, but limited by screen space information.<br>3 - RTGI. Ray Traced Global Illumination technique. Deprecated, use Lumen Global Illumination instead.<br>4 - Plugin. Use a plugin for Global Illumination.</td></tr><tr><td>r.DynamicRes.ChangePercentageThreshold</td><td>Minimal increase percentage threshold to alow when changing resolution.</td></tr><tr><td>r.DynamicRes.CPUBoundScreenPercentage</td><td>Screen percentage to converge to when CPU bound. This can be used when GPU and CPU share same memory.</td></tr><tr><td>r.DynamicRes.CPUTimeHeadRoom</td><td>Head room for the threads compared GPU time to avoid keep getting resolution fraction shrinking down when CPU bound (in milliseconds).</td></tr><tr><td>r.DynamicRes.FrameTimeBudget</td><td>Frame's time budget in milliseconds.</td></tr><tr><td>r.DynamicRes.FrameWeightExponent</td><td>Recursive weight of frame N-1 against frame N.</td></tr><tr><td>r.DynamicRes.GPUTimingMeasureMethod</td><td>Selects the method to use to measure GPU timings.<br>0: Same as stat unit (default);<br>1: Timestamp queries.</td></tr><tr><td>r.DynamicRes.HistorySize</td><td>Number of frames keept in the history.</td></tr><tr><td>r.DynamicRes.IncreaseAmortizationBlendFactor</td><td>Amortization blend factor when scale resolution back up to reduce resolution fraction oscillations.</td></tr><tr><td>r.DynamicRes.MaxConsecutiveOverbudgetGPUFrameCount</td><td>Maximum number of consecutive frame tolerated over GPU budget.</td></tr><tr><td>r.DynamicRes.MaxScreenPercentage</td><td>Maximal screen percentage.</td></tr><tr><td>r.DynamicRes.MinResolutionChangePeriod</td><td>Minimal number of frames between resolution changes, important to avoid input sample position interferences in TAA upsample.</td></tr><tr><td>r.DynamicRes.MinScreenPercentage</td><td>Minimal screen percentage.</td></tr><tr><td>r.DynamicRes.OperationMode</td><td>Select the operation mode for dynamic resolution.<br>0: Disabled (default);<br>1: Enable according to the game user settings;<br>2: Enable regardless of the game user settings.</td></tr><tr><td>r.DynamicRes.OutlierThreshold</td><td>Ignore frame timing that have Game thread or render thread X time more than frame budget.</td></tr><tr><td>r.DynamicRes.TargetedGPUHeadRoomPercentage</td><td>Targeted GPU headroom (in percent from r.DynamicRes.FrameTimeBudget).</td></tr><tr><td>r.DynamicRes.TestScreenPercentage</td><td>Forces the screen percentage to a particular value with dynamic res.<br>0: Disabled (default); > 0: Screen percentage is enabled.<br></td></tr><tr><td>r.EarlyInitDynamicShadows</td><td>Starts shadow culling tasks earlier in the frame.</td></tr><tr><td>r.EarlyZPass</td><td>Whether to use a depth only pass to initialize Z culling for the base pass. Cannot be changed at runtime.<br>Note: also look at r.EarlyZPassMovable<br>0: off<br>1: good occluders only: not masked, and large on screen<br>2: all opaque (including masked)<br>x: use built in heuristic (default is 3)</td></tr><tr><td>r.EarlyZPassOnlyMaterialMasking</td><td>Whether to compute materials' mask opacity only in early Z pass. Changing this setting requires restarting the editor.<br>Note: Needs r.EarlyZPass == 2 &#x26;&#x26; r.EarlyZPassMovable == 1</td></tr><tr><td>r.EarlyZSortMasked</td><td>Sort EarlyZ masked draws to the end of the draw order.<br></td></tr><tr><td>r.Editor.2DGridFade</td><td>Tweak to define the grid rendering in 2D viewports.</td></tr><tr><td>r.Editor.2DSnapFade</td><td>Tweak to define the grid rendering in 2D viewports.</td></tr><tr><td>r.Editor.2DSnapMin</td><td>Tweak to define the grid rendering in 2D viewports.</td></tr><tr><td>r.Editor.2DSnapScale</td><td>Tweak to define the grid rendering in 2D viewports.</td></tr><tr><td>r.Editor.3DGridFade</td><td>Tweak to define the grid rendering in 3D viewports.</td></tr><tr><td>r.Editor.3DSnapFade</td><td>Tweak to define the grid rendering in 3D viewports.</td></tr><tr><td>r.Editor.AlignedOrthoZoom</td><td>Only affects the editor ortho viewports.<br>0: Each ortho viewport zoom in defined by the viewport width<br>1: All ortho viewport zoom are locked to each other to allow axis lines to be aligned with each other.</td></tr><tr><td>r.Editor.MaxNumInstancesDetails</td><td>Maximum number of instances shown in the details panel. Above this value, instances are hidden by default.<br>&#x3C; 0 : No maximum<br></td></tr><tr><td>r.Editor.NewLevelGrid</td><td>Wether to show the new editor level grid<br>0: off<br>1: Analytical Antialiasing<br>2: Texture based(default)</td></tr><tr><td>r.Editor.SkipSourceControlCheckForEditablePackages</td><td>Whether to skip the source control status check for editable packages, 0: Disable (Default), 1: Enable</td></tr><tr><td>r.Editor.TemporalUpsampleDepth</td><td>Temporal upsample factor of the depth buffer for depth testing editor primitives against.</td></tr><tr><td>r.Editor.Viewport.HighDPI</td><td>Controls whether editor &#x26; PIE viewports can be displayed at high DPI.</td></tr><tr><td>r.Editor.Viewport.MaxRenderingResolution</td><td>Controls the absolute maximum number of rendered pixel in editor viewports.</td></tr><tr><td>r.Editor.Viewport.MinRenderingResolution</td><td>Controls the minimum number of rendered pixel by default in editor viewports.</td></tr><tr><td>r.Editor.Viewport.OverridePIEScreenPercentage</td><td>Apply editor viewports' default screen percentage settings to game viewport clients in PIE.</td></tr><tr><td>r.Editor.Viewport.ScreenPercentage</td><td>Controls the editor viewports' default screen percentage when using r.Editor.Viewport.ScreenPercentageMode=0.</td></tr><tr><td>r.Editor.Viewport.ScreenPercentageMode.NonRealTime</td><td>Controls the default screen percentage mode for non-realtime editor viewports.</td></tr><tr><td>r.Editor.Viewport.ScreenPercentageMode.RealTime</td><td>Controls the default screen percentage mode for realtime editor viewports.</td></tr><tr><td>r.EmitMeshDrawEvents</td><td>Emits a GPU event around each drawing policy draw call. /nUseful for seeing stats about each draw call, however it greatly distorts total time and time per draw call.</td></tr><tr><td>r.Emitter.FastPoolEnable</td><td>Should we use fast pools for emitters.<br>0: Don't pool anything<br>1: Pool the emitters bro (default)<br></td></tr><tr><td>r.Emitter.FastPoolMaxFreeSize</td><td>Max free pool size to keep around without cleaning up.</td></tr><tr><td>r.Emitter.SkipRibbonSpawnInterp</td><td>Ignore velocity based offsets when interpolating. This prevents ribbon quads from overlapping eachother (default=1)</td></tr><tr><td>r.EmitterSpawnRateScale</td><td>A global scale upon the spawn rate of emitters. Emitters can choose to apply or ignore it via their bApplyGlobalSpawnRateScale property.</td></tr><tr><td>r.EnableAsyncComputeTranslucencyLightingVolumeClear</td><td>Whether to clear the translucency lighting volume using async compute.<br></td></tr><tr><td>r.EnableComputeBuildHZB</td><td>If zero, build HZB using graphics pipeline.</td></tr><tr><td>r.EnableDebugSpam_GetObjectPositionAndScale</td><td>Enables or disables debug log spam for a bug in FParticleSystemSceneProxy::GetObjectPositionAndScale()</td></tr><tr><td>r.EnableFrustumCull</td><td>Enables or disables frustum culling. Useful for comparing results to ensure culling is functioning properly.</td></tr><tr><td>r.EnableMorphTargets</td><td>Enable Morph Targets</td></tr><tr><td>r.EnableMultiGPUForkAndJoin</td><td>Whether to allow unused GPUs to speedup rendering by sharing work.<br></td></tr><tr><td>r.EnableStereoEmulation</td><td>Emulate stereo rendering</td></tr><tr><td>r.ExpandAllOcclusionTestedBBoxesAmount</td><td>Amount to expand all occlusion test bounds by.</td></tr><tr><td>r.ExpandNewlyOcclusionTestedBBoxesAmount</td><td>If we don't occlusion test a primitive for r.GFramesNotOcclusionTestedToExpandBBoxes frames, then we expand the BBox when we do occlusion test it for a few frames by this amount. See also r.FramesToExpandNewlyOcclusionTestedBBoxes, r.GFramesNotOcclusionTestedToExpandBBoxes.</td></tr><tr><td>r.ExposureOffset</td><td>For adjusting the exposure on top of post process settings and eye adaptation. For developers only. 0:default</td></tr><tr><td>r.ExrReadAndProcessOnGPU</td><td>Allows reading of Large Uncompressed EXR files directly into Structured Buffer.<br>and be processed on GPU<br></td></tr><tr><td>r.EyeAdaptation.Basic.Compute</td><td>Use Pixel or Compute Shader to compute the basic eye adaptation.<br>= 0 : Pixel Shader<br>> 0 : Compute Shader (default)<br></td></tr><tr><td>r.EyeAdaptation.BlackHistogramBucketInfluence</td><td>This parameter controls how much weight to apply to completely dark 0.0 values in the exposure histogram.<br>When set to 1.0, fully dark pixels will accumulate normally, whereas when set to 0.0 fully dark pixels<br>will have no influence.<br></td></tr><tr><td>r.EyeAdaptation.ExponentialTransitionDistance</td><td>The auto exposure moves linearly, but when it gets ExponentialTransitionDistance F-stops away from the<br>target exposure it switches to as slower exponential function.<br></td></tr><tr><td>r.EyeAdaptation.LensAttenuation</td><td>The camera lens attenuation (q). Set this number to 0.78 for lighting to be unitless (1.0cd/m^2 becomes 1.0 at EV100) or 0.65 to match previous versions (1.0cd/m^2 becomes 1.2 at EV100).</td></tr><tr><td>r.EyeAdaptation.MethodOverride</td><td>Override the camera metering method set in post processing volumes<br>-2: override with custom settings (for testing Basic Mode)<br>-1: no override<br>1: Auto Histogram-based<br>2: Auto Basic<br>3: Manual</td></tr><tr><td>r.EyeAdaptation.PreExposureOverride</td><td>Overide the scene pre-exposure by a custom value.<br>= 0 : No override<br>> 0 : Override PreExposure<br></td></tr><tr><td>r.EyeAdaptation.VisualizeDebugType</td><td>When enabling Show->Visualize->HDR (Eye Adaptation) is enabled, this flag controls the scene color.<br>0: Scene Color after tonemapping (default).<br>1: Histogram Debug<br></td></tr><tr><td>r.EyeAdaptationQuality</td><td>Defines the eye adaptation quality which allows to adjust for quality or performance.<br>&#x3C;=0: off (fastest)<br>1: low quality (e.g. non histogram based, not yet implemented)<br>2: normal quality (default)<br>3: high quality (e.g. screen position localized, not yet implemented)</td></tr><tr><td>r.FastBlurThreshold</td><td>Defines at what radius the Gaussian blur optimization kicks in (estimated 25% - 40% faster).<br>The optimization uses slightly less memory and has a quality loss on smallblur radius.<br>0: use the optimization always (fastest, lowest quality)<br>3: use the optimization starting at a 3 pixel radius (quite fast)<br>7: use the optimization starting at a 7 pixel radius (default)<br>>15: barely ever use the optimization (high quality)</td></tr><tr><td>r.FASTBuild.JobProcessor.MaxTimeWithPendingJobs</td><td>Specifies how much time in seconds we will wait to have the min amount of pending jobs. Past this time, the build will start anyways.<br>Default = 10<br></td></tr><tr><td>r.FASTBuild.JobProcessor.MinBatchSize</td><td>Minimum number of shaders to compile with FASTBuild.<br>Default = 100<br></td></tr><tr><td>r.FASTBuild.JobProcessor.SleepTimeBetweenActions</td><td>How much time the job processor thread should sleep between actions .<br></td></tr><tr><td>r.FASTBuildController.Enabled</td><td>Enables or disables the use of FASTBuild to build shaders.<br>0: Controller will not be used (shaders will be built locally or using other controllers).<br>1: Distribute builds using FASTBuild.</td></tr><tr><td>r.FASTBuildController.SendAllPossibleShaderDependencies</td><td>Send all possible dependencies of the shaders to the remote machines.0: Use dependencies array reported in the task structure.<br>1: Brute-force discover all possible dependencies.<br></td></tr><tr><td>r.FASTBuildController.SendSCWDebugSymbols</td><td>Enable when distributed shader compiler workers crash.<br>0: Do not send along debug information in FASTBuild.<br>1: Send along debug information in FASTBuild.</td></tr><tr><td>r.FastVRam.BokehDOF</td><td></td></tr><tr><td>r.FastVRam.CircleDOF</td><td></td></tr><tr><td>r.FastVRam.CombineLUTs</td><td></td></tr><tr><td>r.FastVRam.CustomDepth</td><td></td></tr><tr><td>r.FastVRam.DBufferA</td><td></td></tr><tr><td>r.FastVRam.DBufferB</td><td></td></tr><tr><td>r.FastVRam.DBufferC</td><td></td></tr><tr><td>r.FastVRam.DBufferMask</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldAOBentNormal</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldAODownsampledBentNormal</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldAOHistory</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldAOScreenGridResources</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldCulledObjectBuffers</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldIrradiance</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldNormal</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldShadows</td><td></td></tr><tr><td>r.FastVRam.DistanceFieldTileIntersectionResources</td><td></td></tr><tr><td>r.FastVRam.Distortion</td><td></td></tr><tr><td>r.FastVRam.DOFPostfilter</td><td></td></tr><tr><td>r.FastVRam.DOFReduce</td><td></td></tr><tr><td>r.FastVRam.DOFSetup</td><td></td></tr><tr><td>r.FastVRam.Downsample</td><td></td></tr><tr><td>r.FastVRam.EyeAdaptation</td><td></td></tr><tr><td>r.FastVRam.ForwardLightingCullingResources</td><td></td></tr><tr><td>r.FastVRam.GBufferA</td><td></td></tr><tr><td>r.FastVRam.GBufferB</td><td></td></tr><tr><td>r.FastVRam.GBufferC</td><td></td></tr><tr><td>r.FastVRam.GBufferD</td><td></td></tr><tr><td>r.FastVRam.GBufferE</td><td></td></tr><tr><td>r.FastVRam.GBufferF</td><td></td></tr><tr><td>r.FastVRam.GBufferVelocity</td><td></td></tr><tr><td>r.FastVRam.GlobalDistanceFieldCullGridBuffers</td><td></td></tr><tr><td>r.FastVRam.Histogram</td><td></td></tr><tr><td>r.FastVRam.HistogramReduce</td><td></td></tr><tr><td>r.FastVRam.HZB</td><td></td></tr><tr><td>r.FastVRam.MotionBlur</td><td></td></tr><tr><td>r.FastVRam.PostProcessMaterial</td><td></td></tr><tr><td>r.FastVRam.SceneColor</td><td></td></tr><tr><td>r.FastVRam.SceneDepth</td><td></td></tr><tr><td>r.FastVRam.ScreenSpaceAO</td><td></td></tr><tr><td>r.FastVRam.ScreenSpaceShadowMask</td><td></td></tr><tr><td>r.FastVRam.SeparateTranslucency</td><td></td></tr><tr><td>r.FastVRam.SeparateTranslucencyModulate</td><td></td></tr><tr><td>r.FastVRam.ShadowCSM</td><td></td></tr><tr><td>r.FastVRam.ShadowPerObject</td><td></td></tr><tr><td>r.FastVRam.ShadowPointLight</td><td></td></tr><tr><td>r.FastVRam.SSR</td><td></td></tr><tr><td>r.FastVRam.Tonemap</td><td></td></tr><tr><td>r.FastVRam.Upscale</td><td></td></tr><tr><td>r.FastVRam.VelocityFlat</td><td></td></tr><tr><td>r.FastVRam.VelocityMax</td><td></td></tr><tr><td>r.FastVRam.VolumetricFog</td><td></td></tr><tr><td>r.FeatureLevelPreview</td><td>If 1 the quick settings menu will contain an option to enable feature level preview modes</td></tr><tr><td>r.FilmGrain</td><td>Whether to enable film grain.</td></tr><tr><td>r.FilmGrain.CacheTextureConstants</td><td>Wether the constants related to the film grain should be cached.</td></tr><tr><td>r.FilmGrain.SequenceLength</td><td>Length of the random sequence for film grain (preferably a prime number, default=97).</td></tr><tr><td>r.Filter.LoopMode</td><td>Controls when to use either dynamic or unrolled loops to iterates over the Gaussian filtering.<br>This passes is used for Gaussian Blur, Bloom and Depth of Field. The dynamic loop allows<br>up to 128 samples versus the 32 samples of unrolled loops, but add an additional cost for<br>the loop's stop test at every iterations.<br>0: Unrolled loop only (default; limited to 32 samples).<br>1: Fall back to dynamic loop if needs more than 32 samples.<br>2: Dynamic loop only.</td></tr><tr><td>r.Filter.SizeScale</td><td>Allows to scale down or up the sample count used for bloom and Gaussian depth of field (scale is clamped to give reasonable results).<br>Values down to 0.6 are hard to notice<br>1 full quality (default)<br>>1 more samples (slower)<br>&#x3C;1 less samples (faster, artifacts with HDR content or boxy results with GaussianDOF)</td></tr><tr><td>r.FinishCurrentFrame</td><td>If on, the current frame will be forced to finish and render to the screen instead of being buffered. This will improve latency, but slow down overall performance.</td></tr><tr><td>r.FlushMaterialUniforms</td><td></td></tr><tr><td>r.FlushRHIThreadOnSTreamingTextureLocks</td><td>If set to 0, we won't do any flushes for streaming textures. This is safe because the texture streamer deals with these hazards explicitly.</td></tr><tr><td>r.Fog</td><td>0: disabled<br>1: enabled (default)</td></tr><tr><td>r.FogDensity</td><td>Allows to override the FogDensity setting (needs ExponentialFog in the level).<br>Using a strong value allows to quickly see which pixel are affected by fog.<br>Using a start distance allows to cull pixels are can speed up rendering.<br>&#x3C;0: use default settings (default: -1)<br>>=0: override settings by the given value (0:off, 1=very dense fog)</td></tr><tr><td>r.FogStartDistance</td><td>Allows to override the FogStartDistance setting (needs ExponentialFog in the level).<br>&#x3C;0: use default settings (default: -1)<br>>=0: override settings by the given value (in world units)</td></tr><tr><td>r.FogUseDepthBounds</td><td>Allows enable depth bounds optimization on fog full screen pass.<br>false: disabled<br>true: enabled (default)</td></tr><tr><td>r.ForceAllCoresForShaderCompiling</td><td>When set to 1, it will ignore INI settings and launch as many ShaderCompileWorker instances as cores are available.<br>Improves shader throughput but for big projects it can make the machine run OOM</td></tr><tr><td>r.ForceDebugViewModes</td><td>0: Setting has no effect.<br>1: Forces debug view modes to be available, even on cooked builds.2: Forces debug view modes to be unavailable, even on editor builds. Removes many shader permutations for faster shader iteration.</td></tr><tr><td>r.ForceHighestMipOnUITextures</td><td>If set to 1, texutres in the UI Group will have their highest mip level forced.</td></tr><tr><td>r.ForceLOD</td><td>LOD level to force, -1 is off.</td></tr><tr><td>r.ForceLODShadow</td><td>LOD level to force for the shadow map generation only, -1 is off.</td></tr><tr><td>r.ForceSceneHasDecals</td><td>Whether to always assume that scene has decals, so we don't switch depth state conditionally. This can significantly reduce total number of PSOs at a minor GPU cost.</td></tr><tr><td>r.Forward.LightGridPixelSize</td><td>Size of a cell in the light grid, in pixels.</td></tr><tr><td>r.Forward.LightGridSizeZ</td><td>Number of Z slices in the light grid.</td></tr><tr><td>r.Forward.LightLinkedListCulling</td><td>Uses a reverse linked list to store culled lights, removing the fixed limit on how many lights can affect a cell - it becomes a global limit instead.</td></tr><tr><td>r.Forward.MaxCulledLightsPerCell</td><td>Controls how much memory is allocated for each cell for light culling. When r.Forward.LightLinkedListCulling is enabled, this is used to compute a global max instead of a per-cell limit on culled lights.</td></tr><tr><td>r.ForwardShading</td><td>Whether to use forward shading on desktop platforms - requires Shader Model 5 hardware.<br>Forward shading has lower constant cost, but fewer features supported. 0:off, 1:on<br>This rendering path is a work in progress with many unimplemented features, notably only a single reflection capture is applied per object and no translucency dynamic shadow receiving.</td></tr><tr><td>r.FramesToExpandNewlyOcclusionTestedBBoxes</td><td>If we don't occlusion test a primitive for r.GFramesNotOcclusionTestedToExpandBBoxes frames, then we expand the BBox when we do occlusion test it for this number of frames. See also r.GFramesNotOcclusionTestedToExpandBBoxes, r.ExpandNewlyOcclusionTestedBBoxesAmount</td></tr><tr><td>r.FreeReflectionScratchAfterUse</td><td>Free reflection scratch render targets after use.</td></tr><tr><td>r.FreeSkeletalMeshBuffers</td><td>Controls whether skeletal mesh buffers are kept in CPU memory to support merging of skeletal meshes.<br>0: Keep buffers(default)<br>1: Free buffers</td></tr><tr><td>r.FreezeMouseCursor</td><td>Free the mouse cursor position, for passes which use it to display debug information.<br>0: default<br>1: freeze mouse cursor position at current location</td></tr><tr><td>r.FrustumCullNumWordsPerTask</td><td>Performance tweak. Controls the granularity for the ParallelFor for frustum culling.</td></tr><tr><td>r.FullScreenMode</td><td>Defines how we do full screen when requested (e.g. command line option -fullscreen or in ini [SystemSettings] fullscreen=true)<br>0: normal full screen (renders faster, more control over vsync, less GPU memory, 10bit color if possible)<br>1: windowed full screen (quick switch between applications and window mode, slight performance loss)<br>any other number behaves like 0</td></tr><tr><td>r.FXAA.Quality</td><td>Selects the quality permutation of FXAA.<br>0: Console<br>1: PC medium-dither 3-sample<br>2: PC medium-dither 5-sample<br>3: PC medium-dither 8-sample<br>4: PC low-dither 12-sample (Default)<br>5: PC extrem quality 12-samples</td></tr><tr><td>r.Gamma</td><td>Gamma on output</td></tr><tr><td>r.GaussianBloom.Cross</td><td>Experimental feature to give bloom kernel a more bright center sample (values between 1 and 3 work without causing aliasing)<br>Existing bloom get lowered to match the same brightness<br>&#x3C;0 for a anisomorphic lens flare look (X only)<br>0 off (default)<br>>0 for a cross look (X and Y)</td></tr><tr><td>r.GBufferDiffuseSampleOcclusion</td><td>Whether the gbuffer contain occlusion information for individual diffuse samples.</td></tr><tr><td>r.GBufferFormat</td><td>Defines the memory layout used for the GBuffer.<br>(affects performance, mostly through bandwidth, quality of normals and material attributes).<br>0: lower precision (8bit per component, for profiling)<br>1: low precision (default)<br>3: high precision normals encoding<br>5: high precision</td></tr><tr><td>r.GeneralPurposeTweak</td><td>Useful for low level shader development to get quick iteration time without having to change any c++ code.<br>Value maps to Frame.GeneralPurposeTweak inside the shaders.<br>Example usage: Multiplier on some value to tweak, toggle to switch between different algorithms (Default: 1.0)<br>DON'T USE THIS FOR ANYTHING THAT IS CHECKED IN. Compiled out in SHIPPING to make cheating a bit harder.</td></tr><tr><td>r.GeneralPurposeTweak2</td><td>Useful for low level shader development to get quick iteration time without having to change any c++ code.<br>Value maps to Frame.GeneralPurposeTweak2 inside the shaders.<br>Example usage: Multiplier on some value to tweak, toggle to switch between different algorithms (Default: 1.0)<br>DON'T USE THIS FOR ANYTHING THAT IS CHECKED IN. Compiled out in SHIPPING to make cheating a bit harder.</td></tr><tr><td>r.GenerateMeshDistanceFields</td><td>Whether to build distance fields of static meshes, needed for Lumen Software Ray Tracing and Distance Field AO, which is used to implement Movable SkyLight shadows.<br>Enabling will increase mesh build times and memory usage. Changing this value will cause a rebuild of all static meshes.</td></tr><tr><td>r.GeometryCollection.Nanite</td><td>Render geometry collections using Nanite.</td></tr><tr><td>r.GeometryCollectionOptimizedTransforms</td><td>Whether to optimize transform update by skipping automatic updates in GPUScene.</td></tr><tr><td>r.GeometryCollectionSetDynamicData.ISPC</td><td>Whether to use ISPC optimizations to set dynamic data in geometry collections</td></tr><tr><td>r.GeometryCollectionTripleBufferUploads</td><td>Whether to triple buffer geometry collection uploads, which allows Lock_NoOverwrite uploads which are much faster on the GPU with large amounts of data.</td></tr><tr><td>r.GFramesNotOcclusionTestedToExpandBBoxes</td><td>If we don't occlusion test a primitive for this many frames, then we expand the BBox when we do occlusion test it for a few frames. See also r.ExpandNewlyOcclusionTestedBBoxesAmount, r.FramesToExpandNewlyOcclusionTestedBBoxes</td></tr><tr><td>r.GlobalDistanceFieldHeightFieldThicknessScale</td><td>Thickness of the height field when it's entered into the global distance field, measured in distance field voxels. Defaults to 4 which means 4x the voxel size as thickness.</td></tr><tr><td>r.GlobalIllumination.Denoiser.HistoryConvolution.KernelSpreadFactor</td><td>Multiplication factor applied on the kernel sample offset (default=3).</td></tr><tr><td>r.GlobalIllumination.Denoiser.HistoryConvolution.SampleCount</td><td>Number of samples to use for history post filter (default = 1).</td></tr><tr><td>r.GlobalIllumination.Denoiser.PreConvolution</td><td>Number of pre-convolution passes (default = 1).</td></tr><tr><td>r.GlobalIllumination.Denoiser.ReconstructionSamples</td><td>Maximum number of samples for the reconstruction pass (default = 16).</td></tr><tr><td>r.GlobalIllumination.Denoiser.TemporalAccumulation</td><td>Accumulates the samples over multiple frames.</td></tr><tr><td>r.gpucrash.collectionenable</td><td>Stores GPU crash data from scoped events when a applicable crash debugging system is available.</td></tr><tr><td>r.gpucrash.datadepth</td><td>Limits the amount of marker scope depth we record for GPU crash debugging to the given scope depth.</td></tr><tr><td>r.GPUCrashDebugging</td><td>Enable vendor specific GPU crash analysis tools</td></tr><tr><td>r.GPUCrashDebugging.Aftermath.Callstack</td><td>Enable callstack capture in Aftermath dumps</td></tr><tr><td>r.GPUCrashDebugging.Aftermath.Markers</td><td>Enable draw event markers in Aftermath dumps</td></tr><tr><td>r.GPUCrashDebugging.Aftermath.ResourceTracking</td><td>Enable resource tracking for Aftermath dumps</td></tr><tr><td>r.GPUCrashDebugging.Aftermath.TrackAll</td><td>Enable maximum tracking for Aftermath dumps</td></tr><tr><td>r.GPUCrashDump</td><td>Enable vendor specific GPU crash dumps</td></tr><tr><td>r.GPUCrashOnOutOfMemory</td><td>Enable crash reporting on GPU OOM</td></tr><tr><td>r.GPUCsvStatsEnabled</td><td>Enables or disables GPU stat recording to CSVs</td></tr><tr><td>r.GPUDefrag.AllowOverlappedMoves</td><td>Allows defrag relocations that partially overlap themselves.<br></td></tr><tr><td>r.GPUDefrag.EnableTimeLimits</td><td>Limits CPU time spent doing GPU defragmentation.<br></td></tr><tr><td>r.GPUDefrag.MaxRelocations</td><td>Limits the number of total relocations in a frame regardless of number of bytes moved..<br></td></tr><tr><td>r.GPUMessage.LogAllMessages</td><td>Log all messages to the console.<br>0: Disabled<br>1: Enabled<br></td></tr><tr><td>r.GPUMessage.MaxBufferSize</td><td>Specifies the maximum size of the GPU message buffer, in KiB.<br>default: 64<br></td></tr><tr><td>r.GPUParticle.AFRReinject</td><td>Toggle optimization when running in AFR to re-inject particle injections on the next GPU rather than doing a slow GPU->GPU transfer of the texture data<br>0: Reinjection off<br>1: Reinjection on</td></tr><tr><td>r.GPUParticle.FixDeltaSeconds</td><td>GPU particle fix delta seconds.</td></tr><tr><td>r.GPUParticle.FixTolerance</td><td>Delta second tolerance before switching to a fix delta seconds.</td></tr><tr><td>r.GPUParticle.MaxNumIterations</td><td>Max number of iteration when using a fix delta seconds.</td></tr><tr><td>r.GPUParticle.Simulate</td><td>Enable or disable GPU particle simulation</td></tr><tr><td>r.GpuProfilerMaxEventBufferSizeKB</td><td>Size of the scratch buffer in kB.</td></tr><tr><td>r.GPUScene.AllowDeferredAllocatorMerges</td><td></td></tr><tr><td>r.GPUScene.DebugDrawRange</td><td>Maximum distance the to draw instance bounds, the default is -1.0 &#x3C;=> infinite range.</td></tr><tr><td>r.GPUScene.DebugMode</td><td>Debug Rendering Mode:<br>0 - (show nothing, decault)<br>1 - Draw All<br>2 - Draw Selected (in the editor)<br>3 - Draw Updated (updated this frame)<br>You can use r.GPUScene.DebugDrawRange to limit the range<br></td></tr><tr><td>r.GPUScene.InstanceBVH</td><td>Add instances to BVH. (WIP)</td></tr><tr><td>r.GPUScene.InstanceUploadViaCreate</td><td>When uploading GPUScene InstanceData, upload via resource creation when the RHI supports it efficiently.</td></tr><tr><td>r.GPUScene.MaxPooledUploadBufferSize</td><td>Maximum size of GPU Scene upload buffer size to pool.</td></tr><tr><td>r.GPUScene.ParallelUpdate</td><td></td></tr><tr><td>r.GPUScene.UploadEveryFrame</td><td>Whether to upload the entire scene's primitive data every frame. Useful for debugging.</td></tr><tr><td>r.GPUScene.ValidateInstanceBuffer</td><td>Whether to readback the GPU instance data and assert if it doesn't match the RT primitive data. Useful for debugging.</td></tr><tr><td>r.GPUScene.ValidatePrimitiveBuffer</td><td>Whether to readback the GPU primitive data and assert if it doesn't match the RT primitive data. Useful for debugging.</td></tr><tr><td>r.GPUSkin.CopyBones.ISPC</td><td>Whether to use ISPC optimizations when copying bones for GPU skinning</td></tr><tr><td>r.GPUSkin.Limit2BoneInfluences</td><td>Whether to use 2 bones influence instead of default 4/8 for GPU skinning. Cannot be changed at runtime.</td></tr><tr><td>r.GpuSkin.Pool</td><td>Should we pool gpu skins.<br>0: Don't pool anything<br>1: Pool gpu skins bro (default)<br></td></tr><tr><td>r.GPUSkin.Support16BitBoneIndex</td><td>If enabled, a new mesh imported will use 8 bit (if &#x3C;=256 bones) or 16 bit (if > 256 bones) bone indices for rendering.</td></tr><tr><td>r.GPUSkin.UnlimitedBoneInfluences</td><td>Whether to use unlimited bone influences instead of default 4/8 for GPU skinning. Cannot be changed at runtime.</td></tr><tr><td>r.GPUSkin.UnlimitedBoneInfluencesThreshold</td><td>Unlimited Bone Influences Threshold to use unlimited bone influences buffer if r.GPUSkin.UnlimitedBoneInfluences is enabled. Should be unsigned int. Cannot be changed at runtime.</td></tr><tr><td>r.GPUStatsChildTimesIncluded</td><td>If this is enabled, the child stat timings will be included in their parents' times.<br>This presents problems for non-hierarchical stats if we're expecting them to add up<br>to the total GPU time, so we probably want this disabled.<br></td></tr><tr><td>r.GPUStatsEnabled</td><td>Enables or disables GPU stat recording</td></tr><tr><td>r.GPUStatsMaxQueriesPerFrame</td><td>Limits the number of timestamps allocated per frame. -1 = no limit</td></tr><tr><td>r.GPUTracingStatsEnabled</td><td>Enables or disables GPU stat recording to tracing profiler</td></tr><tr><td>r.GraphicsAdapter</td><td>User request to pick a specific graphics adapter (e.g. when using a integrated graphics card with a discrete one)<br>For Windows D3D, unless a specific adapter is chosen we reject Microsoft adapters because we don't want the software emulation.<br>This takes precedence over -prefer{AMD|NVidia|Intel} when the value is >= 0.<br>-2: Take the first one that fulfills the criteria<br>-1: Favour non integrated because there are usually faster (default)<br>0: Adapter #0<br>1: Adapter #1, ...</td></tr><tr><td>r.GTAO.Combined</td><td>Enable Spatial Filter for GTAO<br>0: Off<br>1: On (default)<br></td></tr><tr><td>r.GTAO.Downsample</td><td>Perform GTAO at Halfres<br>0: Off<br>1: On (default)<br></td></tr><tr><td>r.GTAO.FalloffEnd</td><td>Distance at when the occlusion completes the fall off.<br></td></tr><tr><td>r.GTAO.FalloffStartRatio</td><td>Ratio of the r.GTAO.FalloffEnd value at which it starts to fall off.<br>Must be Between 0 and 1.<br></td></tr><tr><td>r.GTAO.FilterWidth</td><td>Size of the noise pattern and filter width<br>5: 5x5 Pattern (default)<br>4: 4x4 Pattern<br></td></tr><tr><td>r.GTAO.NumAngles</td><td>How Many Angles we choose per pixel<br>Must be Between 1 and 16.<br></td></tr><tr><td>r.GTAO.PauseJitter</td><td>Whether to pause Jitter when Temporal filter is off<br></td></tr><tr><td>r.GTAO.SpatialFilter</td><td>Enable Spatial Filter for GTAO<br>0: Off<br>1: On (default)<br></td></tr><tr><td>r.GTAO.TemporalFilter</td><td>Enable Temporal Filter for GTAO<br>0: Off<br>1: On (default)<br></td></tr><tr><td>r.GTAO.ThicknessBlend</td><td>A heuristic to bias occlusion for thin or thick objects.<br>0 : Off<br>>0 : On - Bigger values lead to reduced occlusion<br>0.5: On (default)<br></td></tr><tr><td>r.GTAO.Upsample</td><td>Enable Simple or Depth aware upsample filter for GTAO<br>0: Simple<br>1: DepthAware (default)<br></td></tr><tr><td>r.GTAO.UseNormals</td><td>Whether to use GBuffer Normals or Depth Derived normals<br>0: Off<br>1: On (default)<br></td></tr><tr><td>r.GTSyncType</td><td>Determines how the game thread syncs with the render thread, RHI thread and GPU.<br>Syncing to the GPU swap chain flip allows for lower frame latency.<br>0 - Sync the game thread with the render thread (default).<br>1 - Sync the game thread with the RHI thread.<br>2 - Sync the game thread with the GPU swap chain flip (only on supported platforms).<br></td></tr><tr><td>r.HairStrands.AsyncLoad</td><td>Allow groom asset to be loaded asynchronously in the editor</td></tr><tr><td>r.HairStrands.Binding</td><td>Enable/Disable hair binding, i.e., hair attached to skeletal meshes.</td></tr><tr><td>r.HairStrands.BindingValidation</td><td>Enable groom binding validation, which report error/warnings with details about the cause.</td></tr><tr><td>r.HairStrands.Cards</td><td>Enable/Disable hair cards rendering. This variable needs to be turned on when the engine starts.</td></tr><tr><td>r.HairStrands.Cards.AtlasWidthScale</td><td>Scale the cards resolution along the width</td></tr><tr><td>r.HairStrands.Cards.BulkData.AsyncLoading</td><td>Load hair cards/meshes data with async loading so that it is not blocking the rendering thread. This value define the MinLOD at which this happen. Default disabled (-1)</td></tr><tr><td>r.HairStrands.Cards.DebugAtlas</td><td>Draw debug hair cards atlas.</td></tr><tr><td>r.HairStrands.Cards.DebugGuides.Render</td><td>Draw debug hair cards guides (1: Rest, 2: Deformed).</td></tr><tr><td>r.HairStrands.Cards.DebugGuides.Sim</td><td>Draw debug hair sim guides (1: Rest, 2: Deformed).</td></tr><tr><td>r.HairStrands.Cards.DebugIndex</td><td>ID of the hair card to debug</td></tr><tr><td>r.HairStrands.Cards.DebugVoxel</td><td>Draw debug hair cards voxel datas.</td></tr><tr><td>r.HairStrands.Cards.DynamicAtlasRefresh</td><td>Enable dynamic refresh of hair cards texture atlas</td></tr><tr><td>r.HairStrands.Cards.InterpolationType</td><td>Hair cards interpolation type: 0: None, 1:physics simulation, 2: RBF deformation</td></tr><tr><td>r.HairStrands.Cards.MaxAtlasSample</td><td>Max super sampling count when generating cards atlas texture</td></tr><tr><td>r.HairStrands.Cards.MaxClusterCount</td><td>Max number of cluster for debug purpose</td></tr><tr><td>r.HairStrands.Cards.MaxHairStrandsSegmentPerCards</td><td>Limit the number of segment which are raytraced during the cards generation</td></tr><tr><td>r.HairStrands.Cards.WidthScale</td><td>Scale the cards resolution along the width</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution</td><td>Default cards atlas resolution.</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution.LOD0</td><td>Default cards atlas resolution for LOD0.</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution.LOD1</td><td>Default cards atlas resolution for LOD1.</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution.LOD2</td><td>Default cards atlas resolution for LOD2.</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution.LOD3</td><td>Default cards atlas resolution for LOD3.</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution.LOD4</td><td>Default cards atlas resolution for LOD4.</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution.LOD5</td><td>Default cards atlas resolution for LOD5.</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution.LOD6</td><td>Default cards atlas resolution for LOD6.</td></tr><tr><td>r.HairStrands.CardsAtlas.DefaultResolution.LOD7</td><td>Default cards atlas resolution for LOD7.</td></tr><tr><td>r.HairStrands.Cluster.CullingFreezeCamera</td><td>Freeze camera when enabled. It will disable HZB culling because hzb buffer is not frozen.</td></tr><tr><td>r.HairStrands.Cluster.Debug</td><td>Draw debug the world bounding box of hair clusters used for culling optimisation (0:off, 1:visible cluster, 2:culled cluster, 3:colored LOD, 4:LOD info).</td></tr><tr><td>r.HairStrands.Cluster.ForceLOD</td><td>Force a specific hair LOD.</td></tr><tr><td>r.HairStrands.ClusterBuilder.MaxVoxelResolution</td><td>Max voxel resolution used when building hair strands cluster data to avoid too long building time (default:128).</td></tr><tr><td>r.HairStrands.Components.GlobalScattering</td><td>Enable/disable hair BSDF component global scattering</td></tr><tr><td>r.HairStrands.Components.LocalScattering</td><td>Enable/disable hair BSDF component local scattering</td></tr><tr><td>r.HairStrands.Components.R</td><td>Enable/disable hair BSDF component R</td></tr><tr><td>r.HairStrands.Components.TRT</td><td>Enable/disable hair BSDF component TRT</td></tr><tr><td>r.HairStrands.Components.TT</td><td>Enable/disable hair BSDF component TT</td></tr><tr><td>r.HairStrands.Components.TTModel</td><td>Select hair TT model</td></tr><tr><td>r.HairStrands.ComposeAfterTranslucency</td><td>0: Compose hair before translucent objects. 1: Compose hair after translucent objects, but before separate translucent objects. 2: Compose hair after all/seperate translucent objects, 3: Compose hair after translucent objects but before translucent render after DOF (which allows depth testing against hair depth)</td></tr><tr><td>r.HairStrands.DDCLog</td><td>Enable DDC logging for groom assets and groom binding assets</td></tr><tr><td>r.HairStrands.DebugData.MaxSegmentPerVoxel</td><td>Max number of segments per Voxel size when creating debug data.</td></tr><tr><td>r.HairStrands.DebugData.VoxelSize</td><td>Voxel size use for creating debug data.</td></tr><tr><td>r.HairStrands.DebugMode</td><td>Draw various stats/debug mode about hair rendering</td></tr><tr><td>r.HairStrands.DebugMode.SampleIndex</td><td>Debug value for a given sample index (default:-1, i.e., average sample information).</td></tr><tr><td>r.HairStrands.DebugMode.Tangent</td><td>Draw debug tangent for hair strands and hair cards.</td></tr><tr><td>r.HairStrands.DebugMode.Tangent.TileSize</td><td>Draw debug tangent - Grid size for drawing debug tangent</td></tr><tr><td>r.HairStrands.DeepShadow.AABBScale</td><td>Scaling value for loosing/tighting deep shadow bounding volume</td></tr><tr><td>r.HairStrands.DeepShadow.DebugDOMIndex</td><td>Index of the DOM texture to draw</td></tr><tr><td>r.HairStrands.DeepShadow.DebugDOMScale</td><td>Scaling value for the DeepOpacityMap when drawing the deep shadow stats</td></tr><tr><td>r.HairStrands.DeepShadow.DebugMode</td><td>Color debug mode for deep shadow</td></tr><tr><td>r.HairStrands.DeepShadow.DensityScale</td><td>Set density scale for compensating the lack of hair fiber in an asset</td></tr><tr><td>r.HairStrands.DeepShadow.DepthBiasScale</td><td>Set depth bias scale for transmittance computation</td></tr><tr><td>r.HairStrands.DeepShadow.GPUDriven</td><td>Enable deep shadow to be driven by GPU bounding box, rather CPU ones. This allows more robust behavior</td></tr><tr><td>r.HairStrands.DeepShadow.InjectVoxelDepth</td><td>Inject voxel content to generate the deep shadow map instead of rasterizing groom. This is an experimental path</td></tr><tr><td>r.HairStrands.DeepShadow.KernelAperture</td><td>Set the aperture angle, in degree, used by the kernel for evaluating the hair transmittance when using PCSS kernel</td></tr><tr><td>r.HairStrands.DeepShadow.KernelType</td><td>Set the type of kernel used for evaluating hair transmittance, 0:linear, 1:PCF_2x2, 2: PCF_6x4, 3:PCSS, 4:PCF_6x6_Accurate</td></tr><tr><td>r.HairStrands.DeepShadow.MaxFrustumAngle</td><td>Max deep shadow frustum angle to avoid strong deformation. Default:90</td></tr><tr><td>r.HairStrands.DeepShadow.MipTraversal</td><td>Evaluate transmittance using mip-map traversal (faster).</td></tr><tr><td>r.HairStrands.DeepShadow.RandomType</td><td>Change how traversal jittering is initialized. Valid value are 0, 1, and 2. Each type makes different type of tradeoff.</td></tr><tr><td>r.HairStrands.DeepShadow.Resolution</td><td>Shadow resolution for Deep Opacity Map rendering. (default = 2048)</td></tr><tr><td>r.HairStrands.DeepShadow.ShadowMaskKernelType</td><td>Set the kernel type for filtering shadow cast by hair on opaque geometry (0:2x2, 1:4x4, 2:Gaussian8, 3:Gaussian16, 4:Gaussian8 with transmittance. Default is 4</td></tr><tr><td>r.HairStrands.DeepShadow.ShadowMaskPassType</td><td>Change how shadow mask from hair onto opaque geometry is generated. 0: one pass per hair group, 1: one pass for all groups.</td></tr><tr><td>r.HairStrands.DeepShadow.SuperSampling</td><td>Evaluate transmittance with supersampling. This is expensive and intended to be used only in cine mode.</td></tr><tr><td>r.HairStrands.DOFDepth</td><td>Compose hair with DOF by lerping hair depth based on its opacity.</td></tr><tr><td>r.HairStrands.DualScatteringRoughness</td><td>Override all roughness for the dual scattering evaluation. 0 means no override. Default:0</td></tr><tr><td>r.HairStrands.Dump</td><td>Dump all the loaded groom assets, groom binding assets, and instanciated groom components.</td></tr><tr><td>r.HairStrands.Dump.GroomAsset</td><td>Dump information of all the loaded groom assets.</td></tr><tr><td>r.HairStrands.Dump.GroomBindingAsset</td><td>Dump information of all the loaded groom binding assets.</td></tr><tr><td>r.HairStrands.Dump.GroomComponent</td><td>Dump information of all active groom components.</td></tr><tr><td>r.HairStrands.Enable</td><td>Enable/Disable the entire hair strands system. This affects all geometric representations (i.e., strands, cards, and meshes).</td></tr><tr><td>r.HairStrands.EnableAdaptiveSubsteps</td><td>Enable adaptive solver substeps</td></tr><tr><td>r.HairStrands.HairGroupBuilder.MaxVoxelResolution</td><td>Max voxel resolution used when voxelizing hair strands to transfer group index grom strands to cards. This avoids too long building time (default:64).</td></tr><tr><td>r.HairStrands.HairLUT.AbsorptionCount</td><td>Change the number of slices of the hair LUT for the absorption axis</td></tr><tr><td>r.HairStrands.HairLUT.IncidentAngleCount</td><td>Change the number of slices of the hair LUT for the incident angle axis</td></tr><tr><td>r.HairStrands.HairLUT.RoughnessCount</td><td>Change the number of slices of the hair LUT for the roughness axis</td></tr><tr><td>r.HairStrands.HairLUT.SampleCountScale</td><td>Change the number of sample used for computing the hair LUT. This is a multiplier, default is 1.</td></tr><tr><td>r.HairStrands.Interoplation.FrustumCulling</td><td>Swap rendering buffer at the end of frame. This is an experimental toggle. Default:1</td></tr><tr><td>r.HairStrands.Interpolation.Debug</td><td>Enable debug rendering for hair interpolation</td></tr><tr><td>r.HairStrands.InterpolationMetric.Angle</td><td>Hair strands interpolation metric weights for angle</td></tr><tr><td>r.HairStrands.InterpolationMetric.AngleAttenuation</td><td>Hair strands interpolation angle attenuation</td></tr><tr><td>r.HairStrands.InterpolationMetric.Distance</td><td>Hair strands interpolation metric weights for distance</td></tr><tr><td>r.HairStrands.InterpolationMetric.Length</td><td>Hair strands interpolation metric weights for length</td></tr><tr><td>r.HairStrands.LightFunction</td><td>Enables Light function on hair</td></tr><tr><td>r.HairStrands.LightSampleFormat</td><td>Define the format used for storing the lighting of hair samples (0: RGBA-16bits, 1: RGB-11.11.10bits)</td></tr><tr><td>r.HairStrands.LoadAsset</td><td>Allow groom asset to be loaded</td></tr><tr><td>r.HairStrands.Log</td><td>Enable warning log report for groom related asset (0: no logging, 1: error only, 2: error &#x26; warning only, other: all logs). By default all logging are enabled (-1). Value needs to be set at startup time.</td></tr><tr><td>r.HairStrands.Log.BindingBuilderWarning</td><td>Enable/disable warning during groom binding builder</td></tr><tr><td>r.HairStrands.ManualSkinCache</td><td>If skin cache is not enabled, and grooms use skinning method, this enable a simple skin cache mechanisme for groom. Default:disable</td></tr><tr><td>r.HairStrands.MaterialCompaction.DepthThreshold</td><td>Compaction threshold for depth value for material compaction (in centimeters). Default 1 cm.</td></tr><tr><td>r.HairStrands.MaterialCompaction.TangentThreshold</td><td>Compaciton threshold for tangent value for material compaction (in degrees). Default 10 deg.</td></tr><tr><td>r.HairStrands.MaxSimulatedLOD</td><td>Maximum hair LOD to be simulated</td></tr><tr><td>r.HairStrands.Meshes</td><td>Enable/Disable hair meshes rendering. This variable needs to be turned on when the engine starts.</td></tr><tr><td>r.HairStrands.MeshProjection.DebugInUVsSpace</td><td>Render debug mes projection in UVs space</td></tr><tr><td>r.HairStrands.MeshProjection.DebugSkinCache</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MeshProjection.Render.Deformed.Frames</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MeshProjection.Render.Deformed.Triangles</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MeshProjection.Render.Rest.Frames</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MeshProjection.Render.Rest.Triangles</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MeshProjection.Sim.Deformed.Frames</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MeshProjection.Sim.Deformed.Triangles</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MeshProjection.Sim.Rest.Frames</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MeshProjection.Sim.Rest.Triangles</td><td>Render debug mes projection</td></tr><tr><td>r.HairStrands.MinLOD</td><td>Clamp the min hair LOD to this value, preventing to reach lower/high-quality LOD.</td></tr><tr><td>r.HairStrands.PathTracing.InvalidationDebug</td><td>Enable bounding box drawing for groom element causing path tracer invalidation</td></tr><tr><td>r.HairStrands.PathTracing.InvalidationThreshold</td><td>Define the minimal distance to invalidate path tracer output when groom changes (in cm, default: 0.5mm)<br>Set to a negative value to disable this feature</td></tr><tr><td>r.HairStrands.PlotBsdf</td><td>Debug view for visualizing hair BSDF.</td></tr><tr><td>r.HairStrands.PlotBsdf.BaseColor</td><td>Change the base color / absorption of the debug BSDF plot.</td></tr><tr><td>r.HairStrands.PlotBsdf.Exposure</td><td>Change the exposure of the plot.</td></tr><tr><td>r.HairStrands.PlotBsdf.Roughness</td><td>Change the roughness of the debug BSDF plot.</td></tr><tr><td>r.HairStrands.Projection.MaxTrianglePerIteration</td><td>Change the number of triangles which are iterated over during one projection iteration step. In kilo triangle (e.g., 8 == 8000 triangles). Default is 8.</td></tr><tr><td>r.HairStrands.RasterizationScale</td><td>Rasterization scale to snap strand to pixel</td></tr><tr><td>r.HairStrands.Raytracing</td><td>Enable/Disable hair strands raytracing geometry. This is anopt-in option per groom asset/groom instance.</td></tr><tr><td>r.HairStrands.RaytracingProceduralSplits</td><td>Change how many AABBs are used per hair segment to balance between BVH build cost and ray tracing performance. (default: 4)</td></tr><tr><td>r.HairStrands.RaytracingRadiusScale</td><td>Override the per instance scale factor for raytracing hair strands geometry (0: disabled, >0:enabled)</td></tr><tr><td>r.HairStrands.RectLightingOptim</td><td>Hair Visibility use projected view rect to light only relevant pixels</td></tr><tr><td>r.HairStrands.ScatterSceneLighting</td><td>Enable scene color lighting scattering into hair (valid for short hair only).</td></tr><tr><td>r.HairStrands.Selection.CoverageThreshold</td><td>Coverage threshold for making hair strands outline selection finer</td></tr><tr><td>r.HairStrands.Shadow.CastShadowWhenNonVisible</td><td>Enable shadow casting for hair strands even when culled out from the primary view</td></tr><tr><td>r.HairStrands.Shadow.CullPerObjectShadowCaster</td><td>Enable CPU culling of object casting per-object shadow (stationnary object)</td></tr><tr><td>r.HairStrands.ShadowRasterizationScale</td><td>Rasterization scale to snap strand to pixel in shadow view</td></tr><tr><td>r.HairStrands.Simulation</td><td>Enable/disable hair simulation</td></tr><tr><td>r.HairStrands.Simulation.ResetAll</td><td>Reset hair strands simulation on all groom components.</td></tr><tr><td>r.HairStrands.SimulationMaxDelay</td><td>Maximum tick Delay before starting the simulation</td></tr><tr><td>r.HairStrands.SimulationRestUpdate</td><td>Update the simulation rest pose</td></tr><tr><td>r.HairStrands.SkyAO</td><td>Enable (sky) AO on hair.</td></tr><tr><td>r.HairStrands.SkyAO.DistanceThreshold</td><td>Max distance for occlusion search.</td></tr><tr><td>r.HairStrands.SkyAO.SampleCount</td><td>Number of samples used for evaluating hair AO (default is set to 16).</td></tr><tr><td>r.HairStrands.SkyLighting</td><td>Enable sky lighting on hair.</td></tr><tr><td>r.HairStrands.SkyLighting.ConeAngle</td><td>Cone angle for tracing sky lighting on hair.</td></tr><tr><td>r.HairStrands.SkyLighting.DebugSample</td><td>Enable debug view for visualizing sample used for the sky integration</td></tr><tr><td>r.HairStrands.SkyLighting.DistanceThreshold</td><td>Max distance for occlusion search.</td></tr><tr><td>r.HairStrands.SkyLighting.IntegrationType</td><td>Hair env. lighting integration type (0:Adhoc, 1:Uniform.</td></tr><tr><td>r.HairStrands.SkyLighting.SampleCount</td><td>Number of samples used for evaluating multiple scattering and visible area (default is set to 16).</td></tr><tr><td>r.HairStrands.SkyLighting.TransmissionDensityScale</td><td>Density scale for controlling how much sky lighting is transmitted.</td></tr><tr><td>r.HairStrands.SkyLighting.UseViewHairCount</td><td>Use the view hair count texture for estimating background transmitted light (enabled by default).</td></tr><tr><td>r.HairStrands.StableRasterizationScale</td><td>Rasterization scale to snap strand to pixel for 'stable' hair option. This value can't go below 1.</td></tr><tr><td>r.HairStrands.Strands</td><td>Enable/Disable hair strands rendering</td></tr><tr><td>r.HairStrands.Strands.BulkData.AsyncLoading</td><td>Load hair strands data with async loading so that it is not blocking the rendering thread. This value define the MinLOD at which this happen. Default disabled (-1)</td></tr><tr><td>r.HairStrands.Strands.BulkData.ReleaseAfterUse</td><td>Release CPU bulk data once hair groom/groom binding asset GPU resources are created. This saves memory</td></tr><tr><td>r.HairStrands.Strands.BulkData.Validation</td><td>Validate some hair strands data at serialization/loading time.</td></tr><tr><td>r.HairStrands.Strands.DebugControlPoint</td><td>Draw debug hair strands control points).</td></tr><tr><td>r.HairStrands.Strands.Raytracing.ForceRebuildBVH</td><td>Force BVH rebuild instead of doing a BVH refit when hair positions changed</td></tr><tr><td>r.HairStrands.Strands.TransferPrevPos</td><td>Transfer strands prev. position to current position on LOD switching to avoid large discrepancy causing large motion vector</td></tr><tr><td>r.HairStrands.StrandsMode</td><td>Render debug mode for hair strands. 0:off, 1:simulation strands, 2:render strands with colored simulation strands influence, 3:hair UV, 4:hair root UV, 5: hair seed, 6: dimensions</td></tr><tr><td>r.HairStrands.StrandWidth</td><td>Width of hair strand</td></tr><tr><td>r.HairStrands.Streaming.Prediction</td><td>Enable LOD streaming prediction.</td></tr><tr><td>r.HairStrands.SwapType</td><td>Swap rendering buffer at the end of frame. This is an experimental toggle. Default:1</td></tr><tr><td>r.HairStrands.Textures.DilationCount</td><td>Number of dilation pass run onto the generated hair strands textures (Default:8).</td></tr><tr><td>r.HairStrands.Tile</td><td>Enable tile generation &#x26; usage for hair strands.</td></tr><tr><td>r.HairStrands.UseCardsInsteadOfStrands</td><td>Force cards geometry on all groom elements. If no cards data is available, nothing will be displayed</td></tr><tr><td>r.HairStrands.UseGPUPositionOffset</td><td>Use GPU position offset to improve hair strands position precision.</td></tr><tr><td>r.HairStrands.UseProxyLocalToWorld</td><td>Enable the use of the groom proxy local to world instead of extracting it from the game thread.</td></tr><tr><td>r.HairStrands.VelocityMagnitudeScale</td><td>Velocity magnitude (in pixel) at which a hair will reach its pic velocity-rasterization-scale under motion to reduce aliasing. Default is 100.</td></tr><tr><td>r.HairStrands.VelocityRasterizationScale</td><td>Rasterization scale to snap strand to pixel under high velocity</td></tr><tr><td>r.HairStrands.VelocityThreshold</td><td>Threshold value (in pixel) above which a pixel is forced to be resolve with responsive AA (in order to avoid smearing). Default is 3.</td></tr><tr><td>r.HairStrands.VelocityType</td><td>Type of velocity filtering (0:avg, 1:closest, 2:max). Default is 1.</td></tr><tr><td>r.HairStrands.Visibility.Clear</td><td>Clear hair strands visibility buffer</td></tr><tr><td>r.HairStrands.Visibility.ComputeRaster</td><td>Hair Visiblity uses raster compute.</td></tr><tr><td>r.HairStrands.Visibility.ComputeRaster.MaxPixelCount</td><td>Define the maximal length rasterize in compute.</td></tr><tr><td>r.HairStrands.Visibility.ComputeRaster.SamplePerPixel</td><td>Define the number of sampler per pixel using raster compute.</td></tr><tr><td>r.HairStrands.Visibility.ComputeRaster.Stochastic</td><td>Enable stochastic compute rasterization (faster, but more prone to aliasting). Experimental.</td></tr><tr><td>r.HairStrands.Visibility.FullCoverageThreshold</td><td>Define the coverage threshold at which a pixel is considered fully covered.</td></tr><tr><td>r.HairStrands.Visibility.HairCount.DistanceThreshold</td><td>Distance threshold defining if opaque depth get injected into the 'view-hair-count' buffer.</td></tr><tr><td>r.HairStrands.Visibility.MSAA.MeanSamplePerPixel</td><td>Scale the numer of sampler per pixel for limiting memory allocation (0..1, default 0.5f)</td></tr><tr><td>r.HairStrands.Visibility.MSAA.SamplePerPixel</td><td>Hair strands visibility sample count (2, 4, or 8)</td></tr><tr><td>r.HairStrands.Visibility.PPLL</td><td>Hair Visibility uses per pixel linked list</td></tr><tr><td>r.HairStrands.Visibility.PPLL.Debug</td><td>Draw debug per pixel light list rendering.</td></tr><tr><td>r.HairStrands.Visibility.PPLL.MeanSamplePerPixel</td><td>Scale the maximum number of node allowed for all linked list element (0..1, default 1). It will be width*height*SamplerPerPixel*Scale.</td></tr><tr><td>r.HairStrands.Visibility.PPLL.SamplePerPixel</td><td>The maximum number of node allowed to be independently shaded and composited per pixel. Total amount of node will be width*height*VisibilityPPLLMaxRenderNodePerPixel. The last node is used to aggregate all furthest strands to shade into a single one.</td></tr><tr><td>r.HairStrands.Visibility.SortByDepth</td><td>Sort hair fragment by depth and update their coverage based on ordered transmittance.</td></tr><tr><td>r.HairStrands.Visibility.UseCoverageMappping</td><td>Use hair count to coverage transfer function.</td></tr><tr><td>r.HairStrands.Visibility.WriteVelocityCoverageThreshold</td><td>Define the coverage threshold at which a pixel write its hair velocity (default: 0, i.e., write for all pixel)</td></tr><tr><td>r.HairStrands.Voxelization</td><td>Enable hair voxelization for transmittance evaluation</td></tr><tr><td>r.HairStrands.Voxelization.AABBScale</td><td>Scale the hair macro group bounding box</td></tr><tr><td>r.HairStrands.Voxelization.DensityScale</td><td>Scale the hair density when computing voxel transmittance. Default value is 2 (arbitraty)</td></tr><tr><td>r.HairStrands.Voxelization.DensityScale.AO</td><td>Scale the hair density when computing voxel AO. (Default:-1, it will use the global density scale</td></tr><tr><td>r.HairStrands.Voxelization.DensityScale.Environment</td><td>Scale the hair density when computing voxel environment. (Default:-1, it will use the global density scale</td></tr><tr><td>r.HairStrands.Voxelization.DensityScale.Raytracing</td><td>Scale the hair density when computing voxel raytracing. (Default:-1, it will use the global density scale</td></tr><tr><td>r.HairStrands.Voxelization.DensityScale.Shadow</td><td>Scale the hair density when computing voxel shadow. (Default:-1, it will use the global density scale</td></tr><tr><td>r.HairStrands.Voxelization.DensityScale.Transmittance</td><td>Scale the hair density when computing voxel transmittance. (Default:-1, it will use the global density scale</td></tr><tr><td>r.HairStrands.Voxelization.DepthBiasScale.Environment</td><td>Set depth bias for voxel ray marching for environement lights. Offset the origin position towards the light</td></tr><tr><td>r.HairStrands.Voxelization.DepthBiasScale.Light</td><td>Set depth bias for voxel ray marching for analyticaly light. Offset the origin position towards the light for transmittance computation</td></tr><tr><td>r.HairStrands.Voxelization.DepthBiasScale.Shadow</td><td>Set depth bias for voxel ray marching for analyticaly light. Offset the origin position towards the light for shadow computation</td></tr><tr><td>r.HairStrands.Voxelization.DepthBiasScale.Transmittance</td><td>Set depth bias for voxel ray marching for analyticaly light. Offset the origin position towards the light for transmittance computation</td></tr><tr><td>r.HairStrands.Voxelization.ForceTransmittanceAndShadow</td><td>For transmittance and shadow to be computed with density volume. This requires voxelization is enabled.</td></tr><tr><td>r.HairStrands.Voxelization.GPUDriven</td><td>Enable GPU driven voxelization.</td></tr><tr><td>r.HairStrands.Voxelization.GPUDriven.MaxPageIndexResolution</td><td>Max resolution of the page index. This is used for allocating a conservative page index buffer when GPU driven allocation is enabled.</td></tr><tr><td>r.HairStrands.Voxelization.InjectOpaque.BiasCount</td><td>Bias, in number of voxel, at which opaque depth is injected.</td></tr><tr><td>r.HairStrands.Voxelization.InjectOpaque.MarkCount</td><td>Number of voxel marked as opaque starting along the view direction beneath the opaque surface.</td></tr><tr><td>r.HairStrands.Voxelization.InjectOpaqueDepth</td><td>Inject opaque geometry depth into the voxel volume for acting as occluder.</td></tr><tr><td>r.HairStrands.Voxelization.Raymarching.SteppingScale</td><td>Stepping scale used for raymarching the voxel structure for shadow.</td></tr><tr><td>r.HairStrands.Voxelization.Raymarching.SteppingScale.Environment</td><td>Stepping scale used for raymarching the voxel structure, override scale for env. lighting (default -1).</td></tr><tr><td>r.HairStrands.Voxelization.Raymarching.SteppingScale.Raytracing</td><td>Stepping scale used for raymarching the voxel structure, override scale for raytracing (default -1).</td></tr><tr><td>r.HairStrands.Voxelization.Raymarching.SteppingScale.Shadow</td><td>Stepping scale used for raymarching the voxel structure, override scale for shadow (default -1).</td></tr><tr><td>r.HairStrands.Voxelization.Raymarching.SteppingScale.Transmission</td><td>Stepping scale used for raymarching the voxel structure, override scale for transmittance (default -1).</td></tr><tr><td>r.HairStrands.Voxelization.UseIndiretScatterPageAllocate</td><td>Enable indirect scatter page allocation (faster).</td></tr><tr><td>r.HairStrands.Voxelization.Virtual</td><td>Enable the two voxel hierachy.</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.Adaptive</td><td>Enable adaptive voxel allocation (default = 1)</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.Adaptive.CorrectionSpeed</td><td>Define the speed at which allocation adaption runs (value in 0..1, default = 0.25). A higher number means faster adaptation, but with a risk of oscillation i.e. over and under allocation</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.Adaptive.CorrectionThreshold</td><td>Define the allocation margin to limit over allocation (value in 0..1, default = 0.95)</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.ComputeRasterMaxVoxelCount</td><td>Max number of voxel which are rasterized for a given hair segment. This is for debug purpose only.</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.DebugTraversalType</td><td>Traversal mode (0:linear, 1:mip) for debug voxel visualization.</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.DrawDebugPage</td><td>When voxel debug rendering is enable 1: render the page bounds, instead of the voxel 2: the occupancy within the page (i.e., 8x8x8 brick)</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.ForceMipLevel</td><td>Force a particular mip-level</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.InvalidateEmptyPageIndex</td><td>Invalid voxel page index which does not contain any voxelized data.</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.Jitter</td><td>Change jittered for voxelization/traversal. 0: No jitter 1: Regular randomized jitter: 2: Constant Jitter (default = 1)</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.UseDirectPageAllocation</td><td>Use the indirect page allocation code path, but force internally direct page allocation (for debugging purpose only).</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.VoxelPageCountPerDim</td><td>Number of voxel pages per texture dimension. The voxel page memory is allocated with a 3D texture. This value provide the resolution of this texture.</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.VoxelPageResolution</td><td>Resolution of a voxel page.</td></tr><tr><td>r.HairStrands.Voxelization.Virtual.VoxelWorldSize</td><td>World size of a voxel in cm.</td></tr><tr><td>r.HairStrands.VoxelizationRasterizationScale</td><td>Rasterization scale to snap strand to pixel for voxelization</td></tr><tr><td>r.HairStrands.WriteGBufferData</td><td>Write hair hair material data into GBuffer before post processing run. 0: no write, 1: dummy write into GBuffer A/B (Normal/ShadingModel), 2: write into GBuffer A/B (Normal/ShadingModel). 2: Write entire GBuffer data. (default 1).</td></tr><tr><td>r.HDR.Display.ColorGamut</td><td>Color gamut of the output display:<br>0: Rec709 / sRGB, D65 (default)<br>1: DCI-P3, D65<br>2: Rec2020 / BT2020, D65<br>3: ACES, D60<br>4: ACEScg, D60<br></td></tr><tr><td>r.HDR.Display.OutputDevice</td><td>Device format of the output display:<br>0: sRGB (LDR)<br>1: Rec709 (LDR)<br>2: Explicit gamma mapping (LDR)<br>3: ACES 1000 nit ST-2084 (Dolby PQ) (HDR)<br>4: ACES 2000 nit ST-2084 (Dolby PQ) (HDR)<br>5: ACES 1000 nit ScRGB (HDR)<br>6: ACES 2000 nit ScRGB (HDR)<br>7: Linear EXR (HDR)<br>8: Linear final color, no tone curve (HDR)<br>9: Linear final color with tone curve<br></td></tr><tr><td>r.HDR.EnableHDROutput</td><td>Creates an HDR compatible swap-chain and enables HDR display output.0: Disabled (default)<br>1: Enable hardware-specific implementation<br></td></tr><tr><td>r.HDR.UI.CompositeMode</td><td>Mode used when compositing the UI layer:<br>0: Standard compositing<br>1: Shader pass to improve HDR blending<br></td></tr><tr><td>r.HDR.UI.Level</td><td>Luminance level for UI elements when compositing into HDR framebuffer (default: 1.0).</td></tr><tr><td>r.HeightFields.AtlasDimInTiles</td><td>Number of tiles the atlas has in one dimension</td></tr><tr><td>r.HeightFields.AtlasDownSampleLevel</td><td>Max number of times a suballocation can be down-sampled</td></tr><tr><td>r.HeightFields.AtlasTileSize</td><td>Suballocation granularity</td></tr><tr><td>r.HeightFields.VisibilityAtlasDimInTiles</td><td>Number of tiles the atlas has in one dimension</td></tr><tr><td>r.HeightFields.VisibilityAtlasDownSampleLevel</td><td>Max number of times a suballocation can be down-sampled</td></tr><tr><td>r.HeightFields.VisibilityAtlasTileSize</td><td>Suballocation granularity</td></tr><tr><td>r.HeightFieldShadowing</td><td>Whether the height field shadowing feature is allowed.</td></tr><tr><td>r.HFShadowAverageObjectsPerCullTile</td><td>Determines how much memory should be allocated in height field object culling data structures. Too much = memory waste, too little = flickering due to buffer overflow.</td></tr><tr><td>r.HFShadowQuality</td><td>Defines the height field shadow method which allows to adjust for quality or performance.<br>0:off, 1:low (8 steps), 2:medium (16 steps, default), 3:high (32 steps, hole aware)</td></tr><tr><td>r.HighQualityLightMaps</td><td>If set to 1, allow high quality lightmaps which don't bake in direct lighting of stationary lights</td></tr><tr><td>r.HighResScreenshot.AdditionalCmds</td><td>Additional command to execute when a high res screenshot is requested.</td></tr><tr><td>r.HighResScreenshotDelay</td><td>When high-res screenshots are requested there is a small delay to allow temporal effects to converge.<br>Default: 4. Using a value below the default will disable TemporalAA for improved image quality.</td></tr><tr><td>r.Histogram.UseAtomic</td><td>Uses atomic to speed up the generation of the histogram.</td></tr><tr><td>r.HLOD</td><td>Single argument: 0 or 1 to Disable/Enable HLOD System<br>Multiple arguments: force X where X is the HLOD level that should be forced into view</td></tr><tr><td>r.HLOD.DistanceOverride</td><td>If non-zero, overrides the distance that HLOD transitions will take place for all objects at the HLOD level index, formatting is as follows:<br>'r.HLOD.DistanceOverride 5000, 10000, 20000' would result in HLOD levels 0, 1 and 2 transitioning at 5000, 1000 and 20000 respectively.</td></tr><tr><td>r.HLOD.DistanceOverrideScale</td><td>Scales the value in r.HLOD.DistanceOverride, Default off.<br>This is an optional scale intended to allow game logic to dynamically modify without impacting scalability.<br></td></tr><tr><td>r.HLOD.DitherPauseTime</td><td>HLOD dither pause time in seconds<br></td></tr><tr><td>r.HLOD.ForceDisableCastDynamicShadow</td><td>If non-zero, will set bCastDynamicShadow to false for all LODActors, regardless of the shadowing setting of their subactors.</td></tr><tr><td>r.HLOD.ListUnbuilt</td><td>Lists all unbuilt HLOD actors in the world</td></tr><tr><td>r.HLOD.MaximumLevel</td><td>How far down the LOD hierarchy to allow showing (can be used to limit quality loss and streaming texture memory usage on high scalability settings)<br>-1: No maximum level (default)<br>0: Prevent ever showing a HLOD cluster instead of individual meshes<br>1: Allow only the first level of HLOD clusters to be shown<br>2+: Allow up to the Nth level of HLOD clusters to be shown</td></tr><tr><td>r.HZB.BuildUseCompute</td><td>Selects whether HZB should be built with compute.</td></tr><tr><td>r.HZBOcclusion</td><td>Defines which occlusion system is used.<br>0: Hardware occlusion queries<br>1: Use HZB occlusion system (default, less GPU and CPU cost, more conservative results) 2: Force HZB occlusion system (overrides rendering platform preferences)</td></tr><tr><td>r.IncludeNonVirtualTexturedLightmaps</td><td>If 'r.VirtualTexturedLightmaps' is enabled, controls whether non-VT lightmaps are generated/saved as well.<br>Including non-VT lightmaps will constrain lightmap atlas size, which removes some of the benefit of VT lightmaps.<br>0: Not included.<br>1: Included.</td></tr><tr><td>r.IndirectLightingCache</td><td>Whether to use the indirect lighting cache on dynamic objects. 0 is off, 1 is on (default)</td></tr><tr><td>r.InstanceCulling.AllowBatchedBuildRenderingCommands</td><td>Whether to allow batching BuildRenderingCommands for GPU instance culling</td></tr><tr><td>r.InstanceCulling.AllowInstanceOrderPreservation</td><td>Whether or not to allow instances to preserve instance draw order using GPU compaction.</td></tr><tr><td>r.InstanceCulling.OcclusionCull</td><td>Whether to do per instance occlusion culling for GPU instance culling.</td></tr><tr><td>r.InvalidateCachedShaders</td><td>Invalidate shader cache by making a unique change to ShaderVersion.ush which is included in common.usf.To initiate actual the recompile of all shaders use "recompileshaders changed" or press "Ctrl Shift .".<br>The ShaderVersion.ush file should be automatically checked out but it needs to be checked in to have effect on other machines.</td></tr><tr><td>r.IrisNormal</td><td>0 to disable iris normal.<br>0: off<br>1: on</td></tr><tr><td>r.KeepOverrideVertexColorsOnCPU</td><td>Keeps a CPU copy of override vertex colors. May be required for some blueprints / object spawning.</td></tr><tr><td>r.KeepPreCulledIndicesThreshold</td><td></td></tr><tr><td>r.LandscapeLOD0DistributionScale</td><td>Multiplier for the landscape LOD0DistributionSetting property</td></tr><tr><td>r.LandscapeLODDistributionScale</td><td>Multiplier for the landscape LODDistributionSetting property</td></tr><tr><td>r.LensFlareQuality</td><td>0: off but best for performance<br>1: low quality with good performance<br>2: good quality (default)<br>3: very good quality but bad performance</td></tr><tr><td>r.LightCulling.MaxDistanceOverrideKilometers</td><td>Used to override the maximum far distance at which we can store data in the light grid.<br>If this is increase, you might want to update r.Forward.LightGridSizeZ to a reasonable value according to your use case light count and distribution. &#x3C;=0: off<br>>0: the far distance in kilometers.<br></td></tr><tr><td>r.LightCulling.Quality</td><td>Whether to run compute light culling pass.<br>0: off<br>1: on (default)<br></td></tr><tr><td>r.LightFunctionQuality</td><td>Defines the light function quality which allows to adjust for quality or performance.<br>&#x3C;=0: off (fastest)<br>1: low quality (e.g. half res with blurring, not yet implemented)<br>2: normal quality (default)<br>3: high quality (e.g. super-sampled or colored, not yet implemented)</td></tr><tr><td>r.LightMaxDrawDistanceScale</td><td>Scale applied to the MaxDrawDistance of lights. Useful for fading out local lights more aggressively on some platforms.</td></tr><tr><td>r.LightShaftAllowTAA</td><td>Allows temporal filtering for lightshafts.<br>0: off<br>1: on (default)</td></tr><tr><td>r.LightShaftBlurPasses</td><td>Number of light shaft blur passes.</td></tr><tr><td>r.LightShaftDownSampleFactor</td><td>Downsample factor for light shafts. range: 1..8</td></tr><tr><td>r.LightShaftFirstPassDistance</td><td>Fraction of the distance to the light to blur on the first radial blur pass.</td></tr><tr><td>r.LightShaftNumSamples</td><td>Number of samples per light shaft radial blur pass. Also affects how quickly the blur distance increases with each pass.</td></tr><tr><td>r.LightShaftQuality</td><td>Defines the light shaft quality (mobile and non mobile).<br>0: off<br>1: on (default)</td></tr><tr><td>r.LightShaftRenderToSeparateTranslucency</td><td>If enabled, light shafts will be rendered to the separate translucency buffer.<br>This ensures postprocess materials with BL_BeforeTranslucnecy are applied before light shafts</td></tr><tr><td>r.LimitRenderingFeatures</td><td>Allows to quickly reduce render feature to increase render performance.<br>This is just a quick way to alter multiple show flags and console variables in the game<br>Disabled more feature the higher the number<br>&#x3C;=0:off, order is defined in code (can be documented here when we settled on an order)</td></tr><tr><td>r.ListSceneColorMaterials</td><td>Lists all materials that read from scene color.</td></tr><tr><td>r.LocalExposure</td><td>Whether to support local exposure</td></tr><tr><td>r.LocalExposure.VisualizeDebugMode</td><td>When enabling Show->Visualize->Local Exposure is enabled, this flag controls which mode to use.<br>0: Local Exposure<br>1: Base Luminance<br>2: Detail Luminance<br></td></tr><tr><td>r.LODFadeTime</td><td>How long LOD takes to fade (in seconds).</td></tr><tr><td>r.LogShaderCompilerStats</td><td>When set to 1, Log detailed shader compiler stats.</td></tr><tr><td>r.Lumen.DiffuseIndirect.Allow</td><td>Whether to allow Lumen Global Illumination. Lumen GI is enabled in the project settings, this cvar can only disable it.</td></tr><tr><td>r.Lumen.DiffuseIndirect.CardInterpolateInfluenceRadius</td><td>.</td></tr><tr><td>r.Lumen.DiffuseIndirect.CardTraceEndDistanceFromCamera</td><td></td></tr><tr><td>r.Lumen.DiffuseIndirect.CullGridDistributionLogZOffset</td><td></td></tr><tr><td>r.Lumen.DiffuseIndirect.CullGridDistributionLogZScale</td><td></td></tr><tr><td>r.Lumen.DiffuseIndirect.CullGridDistributionZScale</td><td></td></tr><tr><td>r.Lumen.DiffuseIndirect.CullGridPixelSize</td><td>Size of a cell in the card grid, in pixels.</td></tr><tr><td>r.Lumen.DiffuseIndirect.MeshSDFAverageCulledCount</td><td></td></tr><tr><td>r.Lumen.DiffuseIndirect.MeshSDFRadiusThreshold</td><td></td></tr><tr><td>r.Lumen.DiffuseIndirect.MinSampleRadius</td><td>.</td></tr><tr><td>r.Lumen.DiffuseIndirect.MinTraceDistance</td><td>.</td></tr><tr><td>r.Lumen.DiffuseIndirect.SurfaceBias</td><td>.</td></tr><tr><td>r.Lumen.DiffuseIndirect.TraceStepFactor</td><td>.</td></tr><tr><td>r.Lumen.DiffuseIndirect.VoxelStepFactor</td><td></td></tr><tr><td>r.Lumen.HardwareRayTracing</td><td>Uses Hardware Ray Tracing for Lumen features, when available.<br>Lumen will fall back to Software Ray Tracing otherwise.<br>Note: Hardware ray tracing has significant scene update costs for<br>scenes with more than 100k instances.</td></tr><tr><td>r.Lumen.HardwareRayTracing.FarFieldBias</td><td>Determines bias for the far field traces. Default = 200</td></tr><tr><td>r.Lumen.HardwareRayTracing.Inline</td><td>Uses Hardware Inline Ray Tracing for selected Lumen passes, when available.<br></td></tr><tr><td>r.Lumen.HardwareRayTracing.LightingMode</td><td>Determines the lighting mode (Default = 0)<br>0: interpolate final lighting from the surface cache<br>1: evaluate material, and interpolate irradiance and indirect irradiance from the surface cache<br>2: evaluate material and direct lighting, and interpolate indirect irradiance from the surface cache<br>3: evaluate material, direct lighting, and unshadowed skylighting at the hit point</td></tr><tr><td>r.Lumen.HardwareRayTracing.MaxIterations</td><td>Limit number of ray tracing traversal iterations on supported platfoms.<br>Incomplete misses will be treated as hitting a black surface (can cause overocculsion).<br>Incomplete hits will be treated as a hit (can cause leaking).</td></tr><tr><td>r.Lumen.HardwareRayTracing.MaxTranslucentSkipCount</td><td>Determines the maximum number of translucent surfaces skipped during ray traversal (Default = 2)</td></tr><tr><td>r.Lumen.HardwareRayTracing.PullbackBias</td><td>Determines the pull-back bias when resuming a screen-trace ray (default = 8.0)</td></tr><tr><td>r.Lumen.IrradianceFieldGather</td><td>Whether to use the Irradiance Field Final Gather, an experimental opaque final gather that interpolates from pre-calculated irradiance in probes for cheaper, but lower quality GI.</td></tr><tr><td>r.Lumen.IrradianceFieldGather.ClipmapDistributionBase</td><td>Base of the Pow() that controls the size of each successive clipmap relative to the first.</td></tr><tr><td>r.Lumen.IrradianceFieldGather.ClipmapWorldExtent</td><td>World space extent of the first clipmap</td></tr><tr><td>r.Lumen.IrradianceFieldGather.GridResolution</td><td>Resolution of the probe placement grid within each clipmap</td></tr><tr><td>r.Lumen.IrradianceFieldGather.IrradianceProbeResolution</td><td>Resolution of the probe's 2d irradiance layout.</td></tr><tr><td>r.Lumen.IrradianceFieldGather.NumClipmaps</td><td>Number of radiance cache clipmaps.</td></tr><tr><td>r.Lumen.IrradianceFieldGather.NumMipmaps</td><td>Number of radiance cache mipmaps.</td></tr><tr><td>r.Lumen.IrradianceFieldGather.NumProbesToTraceBudget</td><td>Number of probes that can be updated in a frame before downsampling.</td></tr><tr><td>r.Lumen.IrradianceFieldGather.OcclusionProbeResolution</td><td>Resolution of the probe's 2d occlusion layout.</td></tr><tr><td>r.Lumen.IrradianceFieldGather.ProbeAtlasResolutionInProbes</td><td>Number of probes along one dimension of the probe atlas cache texture. This controls the memory usage of the cache. Overflow currently results in incorrect rendering.</td></tr><tr><td>r.Lumen.IrradianceFieldGather.ProbeOcclusionNormalBias</td><td>Bias along the normal to reduce self-occlusion artifacts from Probe Occlusion</td></tr><tr><td>r.Lumen.IrradianceFieldGather.ProbeOcclusionViewBias</td><td>Bias along the view direction to reduce self-occlusion artifacts from Probe Occlusion</td></tr><tr><td>r.Lumen.IrradianceFieldGather.ProbeResolution</td><td>Resolution of the probe's 2d radiance layout. The number of rays traced for the probe will be ProbeResolution ^ 2</td></tr><tr><td>r.Lumen.IrradianceFieldGather.RadianceCache.Stats</td><td>GPU print out Radiance Cache update stats.</td></tr><tr><td>r.Lumen.MaxConeSteps</td><td>Maximum steps to use for Cone Stepping of proxy cards.</td></tr><tr><td>r.Lumen.ProbeHierarchy</td><td>Whether to use probe based denoiser for all indirect lighting.</td></tr><tr><td>r.Lumen.ProbeHierarchy.AdditionalSpecularRayThreshold</td><td>Roughness treshold under which to shoot an additional ray for specular.</td></tr><tr><td>r.Lumen.ProbeHierarchy.AntiTileAliasing</td><td>Whether to enable anti tile aliasing.</td></tr><tr><td>r.Lumen.ProbeHierarchy.CounterParrallaxError</td><td>How much parrallax error is tolerated between probe in the hierarchy. Higher value is higher quality, but more expensive.</td></tr><tr><td>r.Lumen.ProbeHierarchy.DebugAntiTileAliasingX</td><td></td></tr><tr><td>r.Lumen.ProbeHierarchy.DebugAntiTileAliasingY</td><td></td></tr><tr><td>r.Lumen.ProbeHierarchy.Depth</td><td>Run time depth of the probe hierarchy (default to 4).</td></tr><tr><td>r.Lumen.ProbeHierarchy.DiffuseIndirect.MipLevel</td><td>Sample the cosine emisphere in specific mip level of the cubemap of the probes to reduce noise when can't afford many rays.</td></tr><tr><td>r.Lumen.ProbeHierarchy.EnableBentNormal</td><td>Whether to occlude GI by material's bent normal.</td></tr><tr><td>r.Lumen.ProbeHierarchy.LeafProbeSamplingDivisor</td><td>Divisor on the number of sample that should be done per texel of the probes' IBL for leaves of the hierarchy.</td></tr><tr><td>r.Lumen.ProbeHierarchy.MaxProbeResolution</td><td>Maximum resolution of the probes' IBL (default to 8, power of two, min at 4, max at 32).</td></tr><tr><td>r.Lumen.ProbeHierarchy.MaxProbeSuperSampling</td><td>Square root maximum of super sampling allowed of ray per texel of the probes' IBL (default to 2, power of two, min at 1, max at 4).</td></tr><tr><td>r.Lumen.ProbeHierarchy.ProbeOcclusion</td><td>Whether to do any probe occlusion.</td></tr><tr><td>r.Lumen.ProbeHierarchy.SamplePerPixel</td><td>Number of sample to do per full res pixel.</td></tr><tr><td>r.Lumen.ProbeHierarchy.ScreenSpaceProbeTracing</td><td>Whether to trace probes with screen space rays.</td></tr><tr><td>r.Lumen.ProbeHierarchy.SSGIProbeOcclusion</td><td>Whether to trace screen space rays to test probe occlusion.</td></tr><tr><td>r.Lumen.ProbeHierarchy.TileClassification</td><td>Whether to use tile classification for faster probe occlusion and probe hierarchy tracing.</td></tr><tr><td>r.Lumen.ProbeHierarchy.TraceMeshSDFs</td><td>.</td></tr><tr><td>r.Lumen.ProbeHierarchy.VoxelDiffuseProbeOcclusion</td><td>Whether to cone trace voxel to test diffuse probe occlusion.</td></tr><tr><td>r.Lumen.RadianceCache.DownsampleDistanceFromCamera</td><td>Probes further than this distance from the camera are always downsampled.</td></tr><tr><td>r.Lumen.RadianceCache.ForceFullUpdate</td><td></td></tr><tr><td>r.Lumen.RadianceCache.HardwareRayTracing</td><td>Enables hardware ray tracing for Lumen radiance cache (Default = 1)</td></tr><tr><td>r.Lumen.RadianceCache.HardwareRayTracing.Indirect</td><td>Enables indirect dispatch for hardware ray tracing for Lumen radiance cache (Default = 1)</td></tr><tr><td>r.Lumen.RadianceCache.HardwareRayTracing.PersistentTracingGroupCount</td><td>Determines the number of trace tile groups to submit in the 1D dispatch</td></tr><tr><td>r.Lumen.RadianceCache.HardwareRayTracing.Retrace.FarField</td><td>Determines whether a second trace will be fired for far-field contribution (Default = 1)</td></tr><tr><td>r.Lumen.RadianceCache.HardwareRayTracing.TemporaryBufferAllocationDownsampleFactor</td><td>Downsample factor on the temporary buffer used by Hardware Ray Tracing Radiance Cache. Higher downsample factors save more transient allocator memory, but may cause overflow and artifacts.</td></tr><tr><td>r.Lumen.RadianceCache.NumFramesToKeepCachedProbes</td><td></td></tr><tr><td>r.Lumen.RadianceCache.OverrideCacheOcclusionLighting</td><td></td></tr><tr><td>r.Lumen.RadianceCache.ShowBlackRadianceCacheLighting</td><td></td></tr><tr><td>r.Lumen.RadianceCache.SortTraceTiles</td><td>Whether to sort Trace Tiles by direction before tracing to extract coherency</td></tr><tr><td>r.Lumen.RadianceCache.SpatialFilterMaxRadianceHitAngle</td><td>In Degrees. Larger angles allow filtering of nearby features but more leaking.</td></tr><tr><td>r.Lumen.RadianceCache.SpatialFilterProbes</td><td>Whether to filter probe radiance between neighbors</td></tr><tr><td>r.Lumen.RadianceCache.SupersampleDistanceFromCamera</td><td>Only probes closer to the camera than this distance can be supersampled.</td></tr><tr><td>r.Lumen.RadianceCache.SupersampleTileBRDFThreshold</td><td>Value of the BRDF [0-1] above which to trace more rays to supersample the probe radiance.</td></tr><tr><td>r.Lumen.RadianceCache.Update</td><td>Whether to update radiance cache every frame</td></tr><tr><td>r.Lumen.RadianceCache.Visualize</td><td></td></tr><tr><td>r.Lumen.RadianceCache.VisualizeClipmapIndex</td><td>Selects which radiance cache clipmap should be visualized. -1 visualizes all clipmaps at once.</td></tr><tr><td>r.Lumen.RadianceCache.VisualizeProbeRadius</td><td>Whether to visualize radiance cache probe radius</td></tr><tr><td>r.Lumen.RadianceCache.VisualizeRadiusScale</td><td>Scales the size of the spheres used to visualize radiance cache samples.</td></tr><tr><td>r.Lumen.Reflections.Allow</td><td>Whether to allow Lumen Reflections. Lumen Reflections is enabled in the project settings, this cvar can only disable it.</td></tr><tr><td>r.Lumen.Reflections.BilateralFilter</td><td>Whether to do a bilateral filter as a last step in denoising Lumen Reflections.</td></tr><tr><td>r.Lumen.Reflections.BilateralFilter.DepthWeightScale</td><td>Scales the depth weight of the bilateral filter</td></tr><tr><td>r.Lumen.Reflections.BilateralFilter.NormalAngleThresholdScale</td><td>Scales the Normal angle threshold of the bilateral filter</td></tr><tr><td>r.Lumen.Reflections.BilateralFilter.NumSamples</td><td>Number of bilateral filter samples.</td></tr><tr><td>r.Lumen.Reflections.BilateralFilter.SpatialKernelRadius</td><td>Spatial kernel radius, as a fraction of the viewport size</td></tr><tr><td>r.Lumen.Reflections.BilateralFilter.StrongBlurVarianceThreshold</td><td>Pixels whose variance from the spatial resolve filter are higher than this value get a stronger bilateral blur.</td></tr><tr><td>r.Lumen.Reflections.DownsampleFactor</td><td></td></tr><tr><td>r.Lumen.Reflections.GGXSamplingBias</td><td></td></tr><tr><td>r.Lumen.Reflections.HairStrands.ScreenTrace</td><td>Whether to trace against hair depth for hair casting shadow onto opaques.</td></tr><tr><td>r.Lumen.Reflections.HairStrands.VoxelTrace</td><td>Whether to trace against hair voxel structure for hair casting shadow onto opaques.</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing</td><td>Enables hardware ray tracing for Lumen reflections (Default = 1)</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing.BucketMaterials</td><td>Determines whether a secondary traces will be bucketed for coherent material access (default = 1</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing.Default.GroupCount</td><td>Determines the active number of groups (Default = 1)</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing.Default.ThreadCount</td><td>Determines the active number of threads (Default = 32768)</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing.Indirect</td><td>Enables indirect ray tracing dispatch on compatible hardware (Default = 1)</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing.Retrace.FarField</td><td>Determines whether a second trace will be fired for far-field contribution (Default = 1)</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing.Retrace.GroupCount</td><td>Determines the active number of groups for re-traces (Default = 1)</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing.Retrace.HitLighting</td><td>Determines whether a second trace will be fired for hit-lighting for invalid surface-cache hits (Default = 0)</td></tr><tr><td>r.Lumen.Reflections.HardwareRayTracing.Retrace.ThreadCount</td><td>Determines the active number of threads for re-traces (Default = 32768)</td></tr><tr><td>r.Lumen.Reflections.HierarchicalScreenTraces.HistoryDepthTestRelativeThickness</td><td>Distance between HZB trace hit and previous frame scene depth from which to allow hits, as a relative depth threshold.</td></tr><tr><td>r.Lumen.Reflections.HierarchicalScreenTraces.MaxIterations</td><td>Max iterations for HZB tracing.</td></tr><tr><td>r.Lumen.Reflections.HierarchicalScreenTraces.MinimumOccupancy</td><td>Minimum number of threads still tracing before aborting the trace. Can be used for scalability to abandon traces that have a disproportionate cost.</td></tr><tr><td>r.Lumen.Reflections.HierarchicalScreenTraces.RelativeDepthThickness</td><td>Determines depth thickness of objects hit by HZB tracing, as a relative depth threshold.</td></tr><tr><td>r.Lumen.Reflections.MaxRayIntensity</td><td>Clamps the maximum ray lighting intensity (with PreExposure) to reduce fireflies.</td></tr><tr><td>r.Lumen.Reflections.MaxRoughnessToTrace</td><td></td></tr><tr><td>r.Lumen.Reflections.RadianceCache</td><td>Whether to reuse Lumen's ScreenProbeGather Radiance Cache, when it is available. When enabled, reflection rays from rough surfaces are shortened and distant lighting comes from interpolating from the Radiance Cache, speeding up traces.</td></tr><tr><td>r.Lumen.Reflections.RadianceCache.AngleThresholdScale</td><td>Controls when the Radiance Cache is used for distant lighting. A value of 1 means only use the Radiance Cache when appropriate for the reflection cone, lower values are more aggressive.</td></tr><tr><td>r.Lumen.Reflections.RadianceCache.ReprojectionRadiusScale</td><td>Scales the radius of the sphere around each Radiance Cache probe that is intersected for parallax correction when interpolating from the Radiance Cache.</td></tr><tr><td>r.Lumen.Reflections.RoughnessFadeLength</td><td></td></tr><tr><td>r.Lumen.Reflections.ScreenSpaceReconstruction</td><td>Whether to use the screen space BRDF reweighting reconstruction</td></tr><tr><td>r.Lumen.Reflections.ScreenSpaceReconstruction.KernelRadius</td><td>Screen space reflection filter kernel radius in pixels</td></tr><tr><td>r.Lumen.Reflections.ScreenSpaceReconstruction.NumSamples</td><td>Number of samples to use for the screen space BRDF reweighting reconstruction</td></tr><tr><td>r.Lumen.Reflections.ScreenSpaceReconstruction.RoughnessScale</td><td>Values higher than 1 allow neighbor traces to be blurred together more aggressively, but is not physically correct.</td></tr><tr><td>r.Lumen.Reflections.ScreenTraces</td><td>Whether to trace against the screen for reflections before falling back to other methods.</td></tr><tr><td>r.Lumen.Reflections.SmoothBias</td><td>Values larger than 0 apply a global material roughness bias for Lumen Reflections, where 1 is fully mirror.</td></tr><tr><td>r.Lumen.Reflections.SurfaceCacheFeedback</td><td>Whether to allow writing into virtual surface cache feedback buffer from reflection rays.</td></tr><tr><td>r.Lumen.Reflections.Temporal</td><td>Whether to use a temporal filter</td></tr><tr><td>r.Lumen.Reflections.Temporal.DistanceThreshold</td><td>World space distance threshold needed to discard last frame's lighting results. Lower values reduce ghosting from characters when near a wall but increase flickering artifacts.</td></tr><tr><td>r.Lumen.Reflections.Temporal.MaxFramesAccumulated</td><td></td></tr><tr><td>r.Lumen.Reflections.TraceCompaction.GroupSizeInTraceTiles</td><td>Size of the trace compaction threadgroup. Larger group = better coherency in the compacted traces. Currently only supported by WaveOps path.</td></tr><tr><td>r.Lumen.Reflections.TraceCompaction.WaveOps</td><td>Whether to use Wave Ops path for trace compaction.</td></tr><tr><td>r.Lumen.Reflections.TraceMeshSDFs</td><td></td></tr><tr><td>r.Lumen.Reflections.VisualizeTracingCoherency</td><td>Set to 1 to capture traces from a random wavefront and draw them on the screen. Set to 1 again to re-capture. Shaders must enable support first, see DEBUG_SUPPORT_VISUALIZE_TRACE_COHERENCY</td></tr><tr><td>r.Lumen.ScreenProbeGather</td><td>Whether to use the Screen Probe Final Gather</td></tr><tr><td>r.Lumen.ScreenProbeGather.AdaptiveProbeAllocationFraction</td><td>Fraction of uniform probes to allow for adaptive probe placement.</td></tr><tr><td>r.Lumen.ScreenProbeGather.AdaptiveProbeMinDownsampleFactor</td><td>Screen probes will be placed where needed down to this downsample factor of the GBuffer.</td></tr><tr><td>r.Lumen.ScreenProbeGather.DiffuseIntegralMethod</td><td>Spherical Harmonic = 0, Importance Sample BRDF = 1, Numerical Integral Reference = 2</td></tr><tr><td>r.Lumen.ScreenProbeGather.DownsampleFactor</td><td>Pixel size of the screen tile that a screen probe will be placed on.</td></tr><tr><td>r.Lumen.ScreenProbeGather.Filtering.WaveOps</td><td>Whether to use Wave Ops path for screen probe filtering.</td></tr><tr><td>r.Lumen.ScreenProbeGather.FixedJitterIndex</td><td>If zero or greater, overrides the temporal jitter index with a fixed index. Useful for debugging and inspecting sampling patterns.</td></tr><tr><td>r.Lumen.ScreenProbeGather.FullResolutionJitterWidth</td><td>Size of the full resolution jitter applied to Screen Probe upsampling, as a fraction of a screen tile. A width of 1 results in jittering by DownsampleFactor number of pixels.</td></tr><tr><td>r.Lumen.ScreenProbeGather.GatherNumMips</td><td>Number of mip maps to prepare for diffuse integration</td></tr><tr><td>r.Lumen.ScreenProbeGather.GatherOctahedronResolutionScale</td><td>Resolution that probe filtering and integration will happen at, as a scale of TracingOctahedronResolution</td></tr><tr><td>r.Lumen.ScreenProbeGather.HairStrands.ScreenTrace</td><td>Whether to trace against hair depth for hair casting shadow onto opaques.</td></tr><tr><td>r.Lumen.ScreenProbeGather.HairStrands.VoxelTrace</td><td>Whether to trace against hair voxel structure for hair casting shadow onto opaques.</td></tr><tr><td>r.Lumen.ScreenProbeGather.HardwareRayTracing</td><td>0. Software raytracing of diffuse indirect from Lumen cubemap tree.1. Enable hardware ray tracing of diffuse indirect. (Default)<br></td></tr><tr><td>r.Lumen.ScreenProbeGather.HardwareRayTracing.AvoidSelfIntersectionTraceDistance</td><td>Distance to trace with backface culling enabled, useful when the Ray Tracing geometry doesn't match the GBuffer (Nanite Proxy geometry)</td></tr><tr><td>r.Lumen.ScreenProbeGather.HardwareRayTracing.Default.GroupCount</td><td>Determines the active number of groups (Default = 1)</td></tr><tr><td>r.Lumen.ScreenProbeGather.HardwareRayTracing.Default.ThreadCount</td><td>Determines the active number of threads (Default = 32768)</td></tr><tr><td>r.Lumen.ScreenProbeGather.HardwareRayTracing.Indirect</td><td>Enables indirect ray tracing dispatch on compatible hardware (Default = 1)</td></tr><tr><td>r.Lumen.ScreenProbeGather.HardwareRayTracing.NormalBias</td><td>Bias along the shading normal, useful when the Ray Tracing geometry doesn't match the GBuffer (Nanite Proxy geometry)</td></tr><tr><td>r.Lumen.ScreenProbeGather.HardwareRayTracing.Retrace.FarField</td><td>Determines whether a second trace will be fired for far-field contribution (Default = 1)</td></tr><tr><td>r.Lumen.ScreenProbeGather.ImportanceSample</td><td>Whether to use Importance Sampling to generate probe trace directions.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ImportanceSample.BRDFOctahedronResolution</td><td>Resolution of the BRDF PDF octahedron per probe.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ImportanceSample.HistoryDistanceThreshold</td><td></td></tr><tr><td>r.Lumen.ScreenProbeGather.ImportanceSample.IncomingLighting</td><td>Whether to Importance Sample incoming lighting to generate probe trace directions. When disabled, only the BRDF will be importance sampled.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ImportanceSample.MinPDFToTrace</td><td>Minimum normalized BRDF PDF to trace rays for. Larger values cause black corners, but reduce noise as more rays are able to be reassigned to an important direction.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ImportanceSample.NumLevels</td><td>Number of refinement levels to use for screen probe importance sampling. Currently only supported by the serial reference path in ScreenProbeGenerateRaysCS.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ImportanceSample.ProbeRadianceHistory</td><td>Whether to Importance Sample incoming lighting from last frame's filtered traces to generate probe trace directions. When disabled, the Radiance Cache will be used instead.</td></tr><tr><td>r.Lumen.ScreenProbeGather.IntegrationTileClassification</td><td>Whether to use tile classification during diffuse integration. Tile Classification splits compute dispatches by VGPRs for better occupancy, but can introduce errors if implemented incorrectly.</td></tr><tr><td>r.Lumen.ScreenProbeGather.IrradianceFormat</td><td>Prefilter irradiance format<br>0 - SH3 slower<br>1 - Octahedral probe. Faster, but reverts to SH3 when ScreenSpaceBentNormal.ApplyDuringIntegration is enabled</td></tr><tr><td>r.Lumen.ScreenProbeGather.MaxRayIntensity</td><td>Clamps the maximum ray lighting intensity (with PreExposure) to reduce fireflies.</td></tr><tr><td>r.Lumen.ScreenProbeGather.OctahedralSolidAngleTextureSize</td><td>Resolution of the lookup texture to compute Octahedral Solid Angle.</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache</td><td>Whether to enable the Persistent world space Radiance Cache</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.ClipmapDistributionBase</td><td>Base of the Pow() that controls the size of each successive clipmap relative to the first.</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.ClipmapWorldExtent</td><td>World space extent of the first clipmap</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.GridResolution</td><td>Resolution of the probe placement grid within each clipmap</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.NumClipmaps</td><td>Number of radiance cache clipmaps.</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.NumMipmaps</td><td>Number of radiance cache mipmaps.</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.NumProbesToTraceBudget</td><td></td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.ProbeAtlasResolutionInProbes</td><td>Number of probes along one dimension of the probe atlas cache texture. This controls the memory usage of the cache. Overflow currently results in incorrect rendering.</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.ProbeResolution</td><td>Resolution of the probe's 2d radiance layout. The number of rays traced for the probe will be ProbeResolution ^ 2</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.ReprojectionRadiusScale</td><td></td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.Stats</td><td>GPU print out Radiance Cache update stats. Requires r.ShaderPrintEnable 1.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ReferenceMode</td><td>When enabled, traces 1024 uniform rays per probe with no filtering, Importance Sampling or Radiance Caching.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenSpaceBentNormal</td><td>Whether to compute screen space directional occlusion to add high frequency occlusion (contact shadows) which Screen Probes lack due to downsampling.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenSpaceBentNormal.ApplyDuringIntegration</td><td>Whether Screen Space Bent Normal should be applied during BRDF integration, which has higher quality but is before the temporal filter so causes streaking on moving objects.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenSpaceBentNormal.SlopeCompareToleranceScale</td><td>Scales the slope threshold that screen space traces use to determine whether there was a hit.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenTraces</td><td>Whether to trace against the screen before falling back to other tracing methods.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenTraces.HZBTraversal</td><td>Whether to use HZB tracing for SSGI instead of fixed step count intersection. HZB tracing is much more accurate, in particular not missing thin features, but is about ~3x slower.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenTraces.HZBTraversal.HistoryDepthTestRelativeThickness</td><td>Distance between HZB trace hit and previous frame scene depth from which to allow hits, as a relative depth threshold.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenTraces.HZBTraversal.MaxIterations</td><td>Max iterations for HZB tracing.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenTraces.HZBTraversal.NumThicknessStepsToDetermineCertainty</td><td>Number of linear search steps to determine if a hit feature is thin and should be ignored.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenTraces.HZBTraversal.RelativeDepthThickness</td><td>Determines depth thickness of objects hit by HZB tracing, as a relative depth threshold.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenTraces.MinimumOccupancy</td><td>Minimum number of threads still tracing before aborting the trace. Can be used for scalability to abandon traces that have a disproportionate cost.</td></tr><tr><td>r.Lumen.ScreenProbeGather.ScreenTraces.ThicknessScaleWhenNoFallback</td><td>Larger scales effectively treat depth buffer surfaces as thicker for screen traces when there is no Distance Field present to resume the occluded ray.</td></tr><tr><td>r.Lumen.ScreenProbeGather.SpatialFilterHalfKernelSize</td><td>Experimental</td></tr><tr><td>r.Lumen.ScreenProbeGather.SpatialFilterMaxRadianceHitAngle</td><td>In Degrees. Larger angles allow more filtering but lose contact shadows.</td></tr><tr><td>r.Lumen.ScreenProbeGather.SpatialFilterNumPasses</td><td>Number of spatial filter passes</td></tr><tr><td>r.Lumen.ScreenProbeGather.SpatialFilterPositionWeightScale</td><td>Determines how far probes can be in world space while still filtering lighting</td></tr><tr><td>r.Lumen.ScreenProbeGather.SpatialFilterProbes</td><td>Whether to spatially filter probe traces to reduce noise.</td></tr><tr><td>r.Lumen.ScreenProbeGather.StochasticInterpolation</td><td>Where to interpolate screen probes stochastically (1 sample) or bilinearly (4 samples)</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal</td><td>Whether to use a temporal filter</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.ClearHistoryEveryFrame</td><td>Whether to clear the history every frame for debugging</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.DebugForceTracesMoving</td><td></td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.DistanceThreshold</td><td>Relative distance threshold needed to discard last frame's lighting results. Lower values reduce ghosting from characters when near a wall but increase flickering artifacts.</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.FastUpdateModeUseNeighborhoodClamp</td><td>Whether to clamp history values to the current frame's screen space neighborhood, in areas around moving objects.</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.FractionOfLightingMovingForFastUpdateMode</td><td></td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.MaxFastUpdateModeAmount</td><td>Maximum amount of fast-responding temporal filter to use when traces hit a moving object. Values closer to 1 cause more noise, but also faster reaction to scene changes.</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.MaxFramesAccumulated</td><td>Lower values cause the temporal filter to propagate lighting changes faster, but also increase flickering from noise.</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.NeighborhoodClamp</td><td>Whether to use a neighborhood clamp temporal filter instead of depth rejection. Experimental.</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.NormalThreshold</td><td>Maximum angle that the history texel's normal can be from the current pixel to accept it's history lighting, in degrees.</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.RejectBasedOnNormal</td><td>Whether to reject history lighting based on their normal. Increases cost of the temporal filter but can reduce streaking especially around character feet.</td></tr><tr><td>r.Lumen.ScreenProbeGather.Temporal.RelativeSpeedDifferenceToConsiderLightingMoving</td><td></td></tr><tr><td>r.Lumen.ScreenProbeGather.TemporalFilterProbes</td><td>Whether to temporally filter probe traces to reduce noise.</td></tr><tr><td>r.Lumen.ScreenProbeGather.TemporalFilterProbes.HistoryDistanceThreshold</td><td></td></tr><tr><td>r.Lumen.ScreenProbeGather.TemporalFilterProbes.HistoryWeight</td><td></td></tr><tr><td>r.Lumen.ScreenProbeGather.TraceMeshSDFs</td><td>Whether to trace against Mesh Signed Distance fields for Lumen's Screen Probe Gather.</td></tr><tr><td>r.Lumen.ScreenProbeGather.TracingOctahedronResolution</td><td>Resolution of the tracing octahedron. Determines how many traces are done per probe.</td></tr><tr><td>r.Lumen.ScreenProbeGather.VisualizeTraces</td><td>Whether to visualize traces for the center screen probe, useful for debugging</td></tr><tr><td>r.Lumen.ScreenProbeGather.VisualizeTracesFreeze</td><td>Whether to freeze updating the visualize trace data. Note that no changes to cvars or shaders will propagate until unfrozen.</td></tr><tr><td>r.Lumen.Supported</td><td>Whether Lumen is supported at all for the project, regardless of platform. This can be used to avoid compiling shaders and other load time overhead.</td></tr><tr><td>r.Lumen.SurfaceCache.HeightfieldCaptureMargin</td><td>Amount to expand heightfield component bbox for card capture purposes.</td></tr><tr><td>r.Lumen.TraceDistanceScale</td><td>Scales the tracing distance for all tracing methods and Lumen features, used by scalability.</td></tr><tr><td>r.Lumen.TraceMeshSDFs</td><td>Whether Lumen should trace against Mesh Signed Distance fields. When enabled, Lumen's Software Tracing will be more accurate, but scenes with high instance density (overlapping meshes) will have high tracing costs. When disabled, lower resolution Global Signed Distance Field will be used instead.</td></tr><tr><td>r.Lumen.TraceMeshSDFs.Allow</td><td>Whether Lumen should trace against Mesh Signed Distance fields. When enabled, Lumen's Software Tracing will be more accurate, but scenes with high instance density (overlapping meshes) will have high tracing costs. When disabled, lower resolution Global Signed Distance Field will be used instead.</td></tr><tr><td>r.Lumen.TraceMeshSDFs.TraceDistance</td><td>Max trace distance against Mesh Distance Fields and Heightfields.</td></tr><tr><td>r.Lumen.TranslucencyReflections.ClipmapFadeSize</td><td>Size in Radiance Cache probes of the dithered transition region between clipmaps</td></tr><tr><td>r.Lumen.TranslucencyReflections.Enable</td><td>Whether to use the Radiance Cache to provide Lumen Reflections on Translucent Surfaces.</td></tr><tr><td>r.Lumen.TranslucencyReflections.MarkDownsampleFactor</td><td>Downsample factor for marking translucent surfaces in the Lumen Radiance Cache. Too low of factors will cause incorrect Radiance Cache coverage. Should be a power of 2.</td></tr><tr><td>r.Lumen.TranslucencyReflections.ReprojectionRadiusScale</td><td>Larger values treat the Radiance Cache lighting as more distant.</td></tr><tr><td>r.Lumen.TranslucencyVolume.Enable</td><td></td></tr><tr><td>r.Lumen.TranslucencyVolume.EndDistanceFromCamera</td><td></td></tr><tr><td>r.Lumen.TranslucencyVolume.GridDistributionLogZOffset</td><td></td></tr><tr><td>r.Lumen.TranslucencyVolume.GridDistributionLogZScale</td><td></td></tr><tr><td>r.Lumen.TranslucencyVolume.GridDistributionZScale</td><td></td></tr><tr><td>r.Lumen.TranslucencyVolume.GridPixelSize</td><td>Size of a cell in the translucency grid, in pixels.</td></tr><tr><td>r.Lumen.TranslucencyVolume.HardwareRayTracing</td><td>Enables hardware ray tracing for Lumen translucency volume (Default = 1)</td></tr><tr><td>r.Lumen.TranslucencyVolume.MaxRayIntensity</td><td>.</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache</td><td>Whether to use the Radiance Cache for Translucency</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.ClipmapDistributionBase</td><td>Base of the Pow() that controls the size of each successive clipmap relative to the first.</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.ClipmapWorldExtent</td><td>World space extent of the first clipmap</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.FarField</td><td>Whether to trace against the FarField representation</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.GridResolution</td><td>Resolution of the probe placement grid within each clipmap</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.NumMipmaps</td><td>Number of radiance cache mipmaps.</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.NumProbesToTraceBudget</td><td></td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.ProbeAtlasResolutionInProbes</td><td>Number of probes along one dimension of the probe atlas cache texture. This controls the memory usage of the cache. Overflow currently results in incorrect rendering.</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.ProbeResolution</td><td>Resolution of the probe's 2d radiance layout. The number of rays traced for the probe will be ProbeResolution ^ 2</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.ReprojectionRadiusScale</td><td></td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.Stats</td><td>GPU print out Radiance Cache update stats.</td></tr><tr><td>r.Lumen.TranslucencyVolume.RadianceCache.Visualize</td><td></td></tr><tr><td>r.Lumen.TranslucencyVolume.SpatialFilter</td><td>Whether to use a spatial filter on the volume traces.</td></tr><tr><td>r.Lumen.TranslucencyVolume.SpatialFilter.NumPasses</td><td>How many passes of the spatial filter to do</td></tr><tr><td>r.Lumen.TranslucencyVolume.Temporal.HistoryWeight</td><td>How much the history value should be weighted each frame. This is a tradeoff between visible jittering and responsiveness.</td></tr><tr><td>r.Lumen.TranslucencyVolume.Temporal.Jitter</td><td>Whether to apply jitter to each frame's translucency GI computation, achieving temporal super sampling.</td></tr><tr><td>r.Lumen.TranslucencyVolume.TemporalReprojection</td><td>Whether to use temporal reprojection.</td></tr><tr><td>r.Lumen.TranslucencyVolume.TraceFromVolume</td><td>Whether to ray trace from the translucency volume's voxels to gather indirect lighting. Only makes sense to disable if TranslucencyVolume.RadianceCache is enabled.</td></tr><tr><td>r.Lumen.TranslucencyVolume.TraceStepFactor</td><td>.</td></tr><tr><td>r.Lumen.TranslucencyVolume.TracingOctahedronResolution</td><td>Resolution of the tracing octahedron. Determines how many traces are done per voxel of the translucency lighting volume.</td></tr><tr><td>r.Lumen.TranslucencyVolume.VoxelStepFactor</td><td>.</td></tr><tr><td>r.Lumen.TranslucencyVolume.VoxelTraceStartDistanceScale</td><td>.</td></tr><tr><td>r.Lumen.Visualize</td><td>Lumen scene visualization mode.<br>0 - Disable<br>1 - Final lighting<br>2 - Reflection View<br>3 - Surface Cache Coverage<br>4 - Overview<br>5 - Albedo<br>6 - Geometry normals<br>7 - Normals<br>8 - Emissive<br>9 - Opacity<br>10 - Card weights<br>11 - Direct lighting<br>12 - Indirect lighting<br>13 - Local Position (hardware ray-tracing only)<br>14 - Velocity (hardware ray-tracing only)<br>15 - Direct lighting updates<br>16 - Indirect lighting updates<br>17 - Last used pages<br>18 - Last used high res pages</td></tr><tr><td>r.Lumen.Visualize.CardGenerationCluster</td><td></td></tr><tr><td>r.Lumen.Visualize.CardGenerationMaxSurfel</td><td></td></tr><tr><td>r.Lumen.Visualize.CardGenerationSurfels</td><td></td></tr><tr><td>r.Lumen.Visualize.CardGenerationSurfelScale</td><td></td></tr><tr><td>r.Lumen.Visualize.CardInterpolateInfluenceRadius</td><td></td></tr><tr><td>r.Lumen.Visualize.CardPlacement</td><td></td></tr><tr><td>r.Lumen.Visualize.CardPlacementDistance</td><td></td></tr><tr><td>r.Lumen.Visualize.CardPlacementIndex</td><td>Visualize only a single card per mesh.</td></tr><tr><td>r.Lumen.Visualize.CardPlacementLOD</td><td>0 - all<br>1 - only primitives<br>2 - only merged instances<br>3 - only merged components<br>4 - only far field<br></td></tr><tr><td>r.Lumen.Visualize.CardPlacementPrimitives</td><td>Whether to visualize primitive bounding boxes.<br></td></tr><tr><td>r.Lumen.Visualize.ClipmapIndex</td><td>Which clipmap to use for the Lumen scene visualization. -1 uses all possible clipmaps.</td></tr><tr><td>r.Lumen.Visualize.ConeAngle</td><td>Visualize cone angle, in degrees.</td></tr><tr><td>r.Lumen.Visualize.ConeStepFactor</td><td>Cone step scale on sphere radius step size.</td></tr><tr><td>r.Lumen.Visualize.GridPixelSize</td><td></td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing</td><td>Enables visualization of hardware ray tracing (Default = 1)</td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing.BucketMaterials</td><td>Determines whether a secondary traces will be bucketed for coherent material access (default = 1</td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing.Compact</td><td>Determines whether a second trace will be compacted before traversal (default = 1</td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing.DeferredMaterial</td><td>Enables deferred material pipeline (Default = 1)</td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing.DeferredMaterial.TileDimension</td><td>Determines the tile dimension for material sorting (Default = 64)</td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing.GroupCount</td><td>Determines the active group count when dispatching raygen shader (default = 4096</td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing.Retrace.FarField</td><td>Determines whether a second trace will be fired for far-field contribution (default = 1</td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing.Retrace.HitLighting</td><td>Determines whether a second trace will be fired for hit-lighting for invalid surface-cache hits (default = 1</td></tr><tr><td>r.Lumen.Visualize.HardwareRayTracing.ThreadCount</td><td>Determines the active group count when dispatching raygen shader (default = 64</td></tr><tr><td>r.Lumen.Visualize.HiResSurface</td><td>Whether visualization should sample highest available surface data or use lowest res always resident pages.</td></tr><tr><td>r.Lumen.Visualize.IndirectDiffuse</td><td>Visualize Lumen Indirect Diffuse.</td></tr><tr><td>r.Lumen.Visualize.MaxMeshSDFTraceDistance</td><td>Max trace distance for Lumen scene visualization rays. Values below 0 will automatically derrive this from cone angle.</td></tr><tr><td>r.Lumen.Visualize.MaxTraceDistance</td><td></td></tr><tr><td>r.Lumen.Visualize.MinTraceDistance</td><td></td></tr><tr><td>r.Lumen.Visualize.RayTracingGroups</td><td>0 - disable<br>1 - all groups<br>2 - groups with a single instance</td></tr><tr><td>r.Lumen.Visualize.Stats</td><td>Print out Lumen scene stats.</td></tr><tr><td>r.Lumen.Visualize.SurfaceCacheFeedback</td><td>Whether visualization should write surface cache feedback requests into the feedback buffer.</td></tr><tr><td>r.Lumen.Visualize.TraceMeshSDFs</td><td>Whether to use Mesh SDF tracing for lumen scene visualization.</td></tr><tr><td>r.Lumen.Visualize.TraceRadianceCache</td><td>Whether to use radiance cache for Lumen scene visualization.</td></tr><tr><td>r.Lumen.Visualize.ViewMode</td><td>When the viewport view-mode is set to 'Lumen Visualization', this command specifies which of the various channels to display. Values entered other than the allowed values shown below will be ignored.<br>Overview<br>LumenScene<br>ReflectionView<br>SurfaceCache</td></tr><tr><td>r.Lumen.Visualize.VoxelFaceIndex</td><td>Which voxel face to use for the Lumen scene visualization -X,+X,-Y,+Y,-Z,+Z. -1 uses all voxel faces.</td></tr><tr><td>r.Lumen.Visualize.Voxels</td><td>Visualize Lumen voxel Representation.</td></tr><tr><td>r.Lumen.Visualize.VoxelStepFactor</td><td></td></tr><tr><td>r.LumenScene.DirectLighting</td><td></td></tr><tr><td>r.LumenScene.DirectLighting.CloudTransmittance</td><td>Whether to sample cloud shadows when avaible.</td></tr><tr><td>r.LumenScene.DirectLighting.ForceShadowMaps</td><td>Use shadow maps for all lights casting shadows.</td></tr><tr><td>r.LumenScene.DirectLighting.GlobalSDF.ShadowRayBias</td><td>Bias for tracing global SDF shadow rays.</td></tr><tr><td>r.LumenScene.DirectLighting.HardwareRayTracing</td><td>Enables hardware ray tracing for Lumen direct lighting (Default = 1)</td></tr><tr><td>r.LumenScene.DirectLighting.HardwareRayTracing.GroupCount</td><td>Determines the dispatch group count<br></td></tr><tr><td>r.LumenScene.DirectLighting.HardwareRayTracing.HeightfieldProjectionBias</td><td>Applies a projection bias such that an occlusion ray starts on the ray-tracing heightfield representation.<br></td></tr><tr><td>r.LumenScene.DirectLighting.HardwareRayTracing.HeightfieldProjectionBiasSearchRadius</td><td>Determines the search radius for heightfield projection bias. Larger search radius corresponds to increased traversal cost (default = 256).<br></td></tr><tr><td>r.LumenScene.DirectLighting.HardwareRayTracing.Indirect</td><td>Enables indirect dispatch for hardware ray tracing (Default = 1)</td></tr><tr><td>r.LumenScene.DirectLighting.HardwareRayTracing.ShadowRayBias</td><td>Bias for hardware ray tracing shadow rays.</td></tr><tr><td>r.LumenScene.DirectLighting.Heightfield.ShadowRayBias</td><td>Bias for tracing heightfield shadow rays.</td></tr><tr><td>r.LumenScene.DirectLighting.MaxLightsPerTile</td><td></td></tr><tr><td>r.LumenScene.DirectLighting.MeshSDF.ShadowRayBias</td><td>Bias for tracing mesh SDF shadow rays.</td></tr><tr><td>r.LumenScene.DirectLighting.OffscreenShadowing.TraceMeshSDFs</td><td>Whether to trace against Mesh Signed Distance Fields for offscreen shadowing, or to trace against the lower resolution Global SDF.</td></tr><tr><td>r.LumenScene.DirectLighting.OffscreenShadowingTraceStepFactor</td><td></td></tr><tr><td>r.LumenScene.DirectLighting.ReuseShadowMaps</td><td>Whether to use shadow maps for shadowing Lumen Scene, where they are available (onscreen). Offscreen areas will still use ray tracing.</td></tr><tr><td>r.LumenScene.DirectLighting.ShadowMap.SamplingBias</td><td>Bias for sampling shadow maps.</td></tr><tr><td>r.LumenScene.DirectLighting.UpdateFactor</td><td>Controls for how many texels direct lighting will be updated every frame. Texels = SurfaceCacheTexels / Factor.</td></tr><tr><td>r.LumenScene.DirectLighting.VirtualShadowMap</td><td>Whether to sample virtual shadow when avaible.</td></tr><tr><td>r.LumenScene.DirectLighting.VirtualShadowMap.SamplingBias</td><td>Bias for sampling virtual shadow maps.</td></tr><tr><td>r.LumenScene.DistantScene</td><td>0: off, 1: on, 2: only on if r.LumenScene.FastCameraMode is enabled</td></tr><tr><td>r.LumenScene.DistantScene.CardResolution</td><td></td></tr><tr><td>r.LumenScene.DistantScene.CascadeDistributionExponent</td><td></td></tr><tr><td>r.LumenScene.DistantScene.DrawCascadeBounds</td><td></td></tr><tr><td>r.LumenScene.DistantScene.EndDistanceFromCamera</td><td></td></tr><tr><td>r.LumenScene.DistantScene.MaxTraceDistance</td><td></td></tr><tr><td>r.LumenScene.DistantScene.MinInstanceBoundsRadius</td><td></td></tr><tr><td>r.LumenScene.DistantScene.NaniteLODBias</td><td>LOD bias for Nanite geometry in Lumen distant scene representation. 0 - full detail. > 0 - reduced detail.</td></tr><tr><td>r.LumenScene.DistantScene.NumCascades</td><td>Todo - shader only supports 1 cascade</td></tr><tr><td>r.LumenScene.DistantScene.SnapOrigin</td><td></td></tr><tr><td>r.LumenScene.DistantScene.StartDistanceFromCamera</td><td></td></tr><tr><td>r.LumenScene.DistantScene.UpdateCaptures</td><td></td></tr><tr><td>r.LumenScene.DistantScene.UpdatePlacement</td><td></td></tr><tr><td>r.LumenScene.DumpStats</td><td>Whether to log Lumen scene stats on the next frame. 2 - dump mesh DF. 3 - dump LumenScene objects.</td></tr><tr><td>r.LumenScene.FarField</td><td>Enable/Disable Lumen far-field ray tracing.</td></tr><tr><td>r.LumenScene.FarField.DitheredStartDistanceFactor</td><td>Starting distance for far-field dithered t-min, as a percentage of near-field t-max (Default = 0.66f).</td></tr><tr><td>r.LumenScene.FarField.MaxTraceDistance</td><td>Maximum hit-distance for Lumen far-field ray tracing (Default = 1.0e6).</td></tr><tr><td>r.LumenScene.FarField.ReferencePos.Z</td><td>Far-field reference position in Z (default = 100000.0)</td></tr><tr><td>r.LumenScene.FastCameraMode</td><td>Whether to update the Lumen Scene for fast camera movement - lower quality, faster updates so lighting can keep up with the camera.</td></tr><tr><td>r.LumenScene.GlobalSDF.ClipmapExtent</td><td></td></tr><tr><td>r.LumenScene.GlobalSDF.FullyCoveredExpandSurfaceScale</td><td>Scales the half voxel SDF expand used by the Global SDF to reconstruct surfaces that are thinner than the distance between two voxels, erring on the side of over-occlusion.</td></tr><tr><td>r.LumenScene.GlobalSDF.Resolution</td><td></td></tr><tr><td>r.LumenScene.GlobalSDF.UncoveredExpandSurfaceScale</td><td>Scales the half voxel SDF expand used by the Global SDF to reconstruct surfaces that are thinner than the distance between two voxels, for regions of space that only contain Two Sided Mesh SDFs.</td></tr><tr><td>r.LumenScene.GlobalSDF.UncoveredMinStepScale</td><td>Scales the min step size to improve performance, for regions of space that only contain Two Sided Mesh SDFs.</td></tr><tr><td>r.LumenScene.Heightfield.CullForView</td><td>Enables Heightfield culling (default = 1)</td></tr><tr><td>r.LumenScene.Heightfield.FroxelCulling</td><td>Enables Heightfield froxel view culling (default = 1)</td></tr><tr><td>r.LumenScene.Heightfield.MaxTracingSteps</td><td>Sets the maximum steps for heightfield (Landscape) software ray tracing (default = 32)</td></tr><tr><td>r.LumenScene.Heightfield.ReceiverBias</td><td>Extra bias for Landscape surface points. Helps to fix mismatching LOD artifacts between fixed LOD in Surface Cache and Landscape CLOD.</td></tr><tr><td>r.LumenScene.Heightfield.Tracing</td><td>Enables heightfield (Landscape) software ray tracing (default = 1)</td></tr><tr><td>r.LumenScene.Lighting.Feedback</td><td>Whether to prioritize surface cache lighting updates based on the feedback.</td></tr><tr><td>r.LumenScene.Lighting.ForceLightingUpdate</td><td></td></tr><tr><td>r.LumenScene.Lighting.Stats</td><td>GPU print out Lumen lighting update stats. Requires r.ShaderPrintEnable 1.</td></tr><tr><td>r.LumenScene.MeshCardsPerTask</td><td>How many mesh cards to process per single surface cache update task.</td></tr><tr><td>r.LumenScene.ParallelUpdate</td><td>Whether to run the Lumen Scene update in parallel.</td></tr><tr><td>r.LumenScene.PrimitivesPerTask</td><td>How many primitives to process per single surface cache update task.</td></tr><tr><td>r.LumenScene.Radiosity</td><td>Whether to enable the Radiosity, which is an indirect lighting gather from the Surface Cache that provides multibounce diffuse.</td></tr><tr><td>r.LumenScene.Radiosity.DistanceFieldSurfaceBias</td><td>.</td></tr><tr><td>r.LumenScene.Radiosity.DistanceFieldSurfaceSlopeBias</td><td>.</td></tr><tr><td>r.LumenScene.Radiosity.HardwareRayTracing</td><td>Enables hardware ray tracing for radiosity (default = 1).</td></tr><tr><td>r.LumenScene.Radiosity.HardwareRayTracing.AvoidSelfIntersectionTraceDistance</td><td>When greater than zero, a short trace skipping backfaces will be done to escape the surface, followed by the remaining trace that can hit backfaces.</td></tr><tr><td>r.LumenScene.Radiosity.HardwareRayTracing.Indirect</td><td>Enables indirect dispatch for hardware ray tracing for radiosity (default = 1).</td></tr><tr><td>r.LumenScene.Radiosity.HardwareRayTracing.SlopeSurfaceBias</td><td>.</td></tr><tr><td>r.LumenScene.Radiosity.HardwareRayTracing.SurfaceBias</td><td>.</td></tr><tr><td>r.LumenScene.Radiosity.HemisphereProbeResolution</td><td>Number of traces along one dimension of the hemisphere probe layout.</td></tr><tr><td>r.LumenScene.Radiosity.MaxRayIntensity</td><td>Clamps Radiosity trace intensity, relative to current view exposure. Useful for reducing artifacts from small bright emissive sources, but loses energy and adds view dependence.</td></tr><tr><td>r.LumenScene.Radiosity.MinTraceDistanceToSampleSurface</td><td>Ray hit distance from which we can start sampling surface cache in order to fix radiosity feedback loop where surface cache texel hits itself every frame.</td></tr><tr><td>r.LumenScene.Radiosity.ProbeOcclusion</td><td>Whether to depth test against the probe hit depths during interpolation and filtering to reduce leaking. Not available with Software Ray Tracing due to imprecision.</td></tr><tr><td>r.LumenScene.Radiosity.ProbePlaneWeighting</td><td>Whether to weight Radiosity probes by plane distance, useful to prevent leaking.</td></tr><tr><td>r.LumenScene.Radiosity.ProbeSpacing</td><td>Distance between probes, in Surface Cache texels</td></tr><tr><td>r.LumenScene.Radiosity.SpatialFilterProbes</td><td>Whether to spatially filter Radiosity probes. Filtering reduces noise but increases leaking.</td></tr><tr><td>r.LumenScene.Radiosity.SpatialFilterProbes.KernelSize</td><td>Larger kernels reduce noise but increase leaking.</td></tr><tr><td>r.LumenScene.Radiosity.SpatialFilterProbes.PlaneWeightingDepthScale</td><td>Controls the distance at which probes can be interpolated from. Higher values introduce leaking.</td></tr><tr><td>r.LumenScene.Radiosity.Temporal</td><td>Whether to use temporal super sampling on Radiosity. Increases quality, but also adds latency to the speed that lighting changes propagate, and animated noise in the results.</td></tr><tr><td>r.LumenScene.Radiosity.Temporal.FixedJitterIndex</td><td>If zero or greater, overrides the temporal jitter index with a fixed index. Useful for debugging and inspecting sampling patterns.</td></tr><tr><td>r.LumenScene.Radiosity.Temporal.MaxFramesAccumulated</td><td>Lower values cause the temporal filter to propagate lighting changes faster, but also increase flickering from noise.</td></tr><tr><td>r.LumenScene.Radiosity.UpdateFactor</td><td>Controls for how many texels radiosity will be updated every frame. Texels = SurfaceCacheTexels / Factor.</td></tr><tr><td>r.LumenScene.Radiosity.VoxelStepFactor</td><td>.</td></tr><tr><td>r.LumenScene.SurfaceCache.AtlasSize</td><td>Surface cache card atlas size.</td></tr><tr><td>r.LumenScene.SurfaceCache.CardCameraDistanceTexelDensityScale</td><td>Lumen card texels per world space distance</td></tr><tr><td>r.LumenScene.SurfaceCache.CardCaptureFactor</td><td>Controls how many texels can be captured per frame. Texels = SurfaceCacheTexels / Factor.</td></tr><tr><td>r.LumenScene.SurfaceCache.CardCaptureMargin</td><td>How far from Lumen scene range start to capture cards.</td></tr><tr><td>r.LumenScene.SurfaceCache.CardCaptureRefreshFraction</td><td>Fraction of card capture budget allowed to be spent on re-capturing existing pages in order to refresh surface cache materials.<br>0 disables card refresh.</td></tr><tr><td>r.LumenScene.SurfaceCache.CardCapturesPerFrame</td><td></td></tr><tr><td>r.LumenScene.SurfaceCache.CardFixedDebugResolution</td><td>Lumen card resolution</td></tr><tr><td>r.LumenScene.SurfaceCache.CardMaxResolution</td><td>Maximum card resolution in Lumen Scene</td></tr><tr><td>r.LumenScene.SurfaceCache.CardMaxTexelDensity</td><td>Lumen card texels per world space distance</td></tr><tr><td>r.LumenScene.SurfaceCache.CardMinResolution</td><td>Minimum mesh card size resolution to be visible in Lumen Scene</td></tr><tr><td>r.LumenScene.SurfaceCache.Compress</td><td>Whether to use run time compression for surface cache.<br>0 - Disabled<br>1 - Compress using UAV aliasing if supported<br>2 - Compress using CopyTexture (may be very slow on some RHIs)<br></td></tr><tr><td>r.LumenScene.SurfaceCache.DiffuseReflectivityOverride</td><td>Override captured material diffuse for debugging. 0 disables override.</td></tr><tr><td>r.LumenScene.SurfaceCache.FarField.Distance</td><td>Far Field Lumen card culling distance</td></tr><tr><td>r.LumenScene.SurfaceCache.FarField.TexelDensity</td><td>Far Field Lumen card texels per world space unit</td></tr><tr><td>r.LumenScene.SurfaceCache.Feedback</td><td>Whether to use surface cache feedback to selectively map higher quality surface cache pages.</td></tr><tr><td>r.LumenScene.SurfaceCache.Feedback.MinPageHits</td><td>Min number of page hits to demand a new page.</td></tr><tr><td>r.LumenScene.SurfaceCache.Feedback.ResLevelBias</td><td>Bias resolution of on demand surface cache pages.</td></tr><tr><td>r.LumenScene.SurfaceCache.Feedback.TileSize</td><td>One surface cache feedback element will be writen out per tile. Aligned to a power of two.</td></tr><tr><td>r.LumenScene.SurfaceCache.Feedback.UniqueElements</td><td>Limit of unique surface cache feedback elements. Used to resize buffers.</td></tr><tr><td>r.LumenScene.SurfaceCache.ForceEvictHiResPages</td><td>Evict all optional hi-res surface cache pages.</td></tr><tr><td>r.LumenScene.SurfaceCache.Freeze</td><td>Freeze surface cache updates for debugging.<br></td></tr><tr><td>r.LumenScene.SurfaceCache.FreezeUpdateFrame</td><td>Keep updating the same subset of surface cache for debugging and profiling.<br></td></tr><tr><td>r.LumenScene.SurfaceCache.LogUpdates</td><td>Whether to log Lumen surface cache updates.<br>2 - will log mesh names.</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsCullFaces</td><td></td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsDebugSingleCard</td><td>Spawn only a specified card on mesh. Useful for debugging.</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsMaxLOD</td><td>Max LOD level for the card representation. 0 - lowest quality.</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsMergeComponents</td><td>Whether to merge all components with the same RayTracingGroupId into a single MeshCards.</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsMergedCardMinSurfaceArea</td><td>Minimum area to spawn a merged card.</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsMergedMaxWorldSize</td><td>Only merged bounds less than this size on any axis are considered, since Lumen Scene streaming relies on object granularity.</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsMergedResolutionScale</td><td>Scale on the resolution calculation for a merged MeshCards. This compensates for the merged box getting a higher resolution assigned due to being closer to the viewer.</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsMergeInstances</td><td>Whether to merge all instances of a Instanced Static Mesh Component into a single MeshCards.</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsMergeInstancesMaxSurfaceAreaRatio</td><td>Only merge if the (combined box surface area) / (summed instance box surface area) &#x3C; MaxSurfaceAreaRatio</td></tr><tr><td>r.LumenScene.SurfaceCache.MeshCardsMinSize</td><td>Minimum mesh cards world space size to be included in Lumen Scene.</td></tr><tr><td>r.LumenScene.SurfaceCache.NaniteMultiViewCapture</td><td>Toggle multi view Lumen Nanite Card capture for debugging.</td></tr><tr><td>r.LumenScene.SurfaceCache.NaniteMultiViewRaster</td><td>Toggle multi view Lumen Nanite Card rasterization for debugging.</td></tr><tr><td>r.LumenScene.SurfaceCache.NumFramesToKeepUnusedPages</td><td>Num frames to keep unused pages in surface cache.</td></tr><tr><td>r.LumenScene.SurfaceCache.RecaptureEveryFrame</td><td></td></tr><tr><td>r.LumenScene.SurfaceCache.ResampleLighting</td><td>Whether to resample card lighting when cards are reallocated. This is needed for Radiosity temporal accumulation but can be disabled for debugging.</td></tr><tr><td>r.LumenScene.SurfaceCache.Reset</td><td>Reset all atlases and captured cards.<br></td></tr><tr><td>r.LumenScene.SurfaceCache.ResetEveryNthFrame</td><td>Continuosly reset all atlases and captured cards every N-th frame.<br></td></tr><tr><td>r.LumenScene.UpdateViewOrigin</td><td>Whether to update view origin for voxel lighting and global distance field. Useful for debugging.</td></tr><tr><td>r.LumenScene.UploadEveryFrame</td><td>Whether to upload the entire Lumen Scene's data every frame. Useful for debugging.</td></tr><tr><td>r.LumenScene.VoxelLighting.AverageObjectsPerVisBufferTile</td><td>Average expected number of objects per vis buffer tile, used to preallocate memory for the cull grid.</td></tr><tr><td>r.LumenScene.VoxelLighting.ClipmapResolution</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.ClipmapWorldExtent</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.ClipmapZResolutionDivisor</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.DistantScene</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.ForceFullUpdate</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.ForceMovementUpdate</td><td>Whether to force N texel border on X, Y and Z update each frame.</td></tr><tr><td>r.LumenScene.VoxelLighting.ForceUpdateClipmapIndex</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.MaskDownsampleShift</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.MeshSDFRadiusThresholdFactor</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.NumClipmapLevels</td><td></td></tr><tr><td>r.LumenScene.VoxelLighting.Reset</td><td>Reset all voxel lighting.<br></td></tr><tr><td>r.LUT.Size</td><td>Size of film LUT</td></tr><tr><td>r.Material.DumpDDCKeys</td><td>if != 0, DDC keys for each material shadermap will be dumped into project's Saved directory (MaterialDDCKeys subdirectory)</td></tr><tr><td>r.Material.EnergyConservation</td><td>Enable energy conservation for material (project settings, read only).</td></tr><tr><td>r.Material.ExcludeNonPipelinedShaders</td><td>if != 0, standalone shaders that are also part of FShaderPipeline will not be compiled (default).</td></tr><tr><td>r.Material.RoughDiffuse</td><td>Enable rough diffuse material.</td></tr><tr><td>r.MaterialEditor.AnalyticDeriv</td><td>Enable analytic derivative code generation.</td></tr><tr><td>r.MaterialEditor.AnalyticDeriv.DebugEmitInvalidDerivTokens</td><td>Debug: Emit '$' tokens to mark expressions with invalid derivatives.<br></td></tr><tr><td>r.MaterialEditor.AnalyticDeriv.DebugGenerateAllFunctions</td><td>Debug: Generate all derivative functions.</td></tr><tr><td>r.MaterialEditor.AnalyticDeriv.DebugTextureSample</td><td>Debug: Instrument texture sampling with modes that can be controlled with r.GeneralPurposeTweak/r.GeneralPurposeTweak2.</td></tr><tr><td>r.MaterialEditor.LWCEnabled</td><td>Enable generation of LWC values in materials. If disabled, materials will perform all operations at float-precision</td></tr><tr><td>r.MaterialEditor.UseDevShaders</td><td>Toggles whether the material editor will use shaders that include extra overhead incurred by the editor. Material editor must be re-opened if changed at runtime.</td></tr><tr><td>r.MaterialEnableControlFlow</td><td>Allows experemental control flow to be used in the material editor.<br></td></tr><tr><td>r.MaterialEnableNewHLSLGenerator</td><td>Enables the new (WIP) material HLSL generator.<br></td></tr><tr><td>r.MaterialParameterLegacyChecks</td><td>When enabled, sanity check new material parameter logic against legacy path.<br>Note that this can be slow</td></tr><tr><td>r.MaterialQualityLevel</td><td>0 corresponds to low quality materials, as defined by quality switches in materials, 1 corresponds to high, 2 for medium, and 3 for Epic.</td></tr><tr><td>r.MaxAnisotropy</td><td>MaxAnisotropy should range from 1 to 16. Higher values mean better texure quality when using anisotropic filtering but at a cost to performance. Default is 4.</td></tr><tr><td>r.MaxCSMRadiusToAllowPerObjectShadows</td><td>Only stationary lights with a CSM radius smaller than this will create per object shadows for dynamic objects.</td></tr><tr><td>r.MaxQualityMode</td><td>If set to 1, override certain system settings to highest quality regardless of performance impact</td></tr><tr><td>r.MaxVertexBytesAllocatedPerFrame</td><td>The maximum number of transient vertex buffer bytes to allocate before we start panic logging who is doing the allocations</td></tr><tr><td>r.MeshCardRepresentation</td><td></td></tr><tr><td>r.MeshCardRepresentation.Async</td><td>.</td></tr><tr><td>r.MeshCardRepresentation.Debug.SurfelDirection</td><td>Generate cards for only surfels pointing in a specific direction.</td></tr><tr><td>r.MeshCardRepresentation.DistanceTresholdXY</td><td>Max distance (in surfels) when surface elements should be clustered together along XY.</td></tr><tr><td>r.MeshCardRepresentation.DistanceTresholdZ</td><td>Max distance (in surfels) when surface elements should be clustered together along Z.</td></tr><tr><td>r.MeshCardRepresentation.GrowIterations</td><td>Max number of grow iterations.</td></tr><tr><td>r.MeshCardRepresentation.MinDensity</td><td>How much of filled area needs to be there to spawn a card, [0;1] range.</td></tr><tr><td>r.MeshCardRepresentation.NormalTreshold</td><td>Normal treshold when surface elements should be clustered together.</td></tr><tr><td>r.MeshCardRepresentation.ParallelBuild</td><td>Whether to use task for mesh card building.</td></tr><tr><td>r.MeshCardRepresentation.SeedIterations</td><td>Max number of clustering iterations.</td></tr><tr><td>r.MeshDrawCommands.AllowOnDemandShaderCreation</td><td>How to create RHI shaders:<br>0: Always create them on a Rendering Thread, before executing other MDC tasks.<br>1: If RHI supports multi-threaded shader creation, create them on demand on tasks threads, at the time of submitting the draws.<br></td></tr><tr><td>r.MeshDrawCommands.CacheMultithreaded</td><td>Enable multithreading of draw command caching for static meshes. 0=disabled, 1=enabled (default)</td></tr><tr><td>r.MeshDrawCommands.DynamicInstancing</td><td>Whether to dynamically combine multiple compatible visible Mesh Draw Commands into one instanced draw on vertex factories that support it.</td></tr><tr><td>r.MeshDrawCommands.LogDynamicInstancingStats</td><td>Whether to log dynamic instancing stats on the next frame</td></tr><tr><td>r.MeshDrawCommands.LogMeshDrawCommandMemoryStats</td><td>Whether to log mesh draw command memory stats on the next frame</td></tr><tr><td>r.MeshDrawCommands.ParallelPassSetup</td><td>Whether to setup mesh draw command pass in parallel.</td></tr><tr><td>r.MeshDrawCommands.UseCachedCommands</td><td>Whether to render from cached mesh draw commands (on vertex factories that support it), or to generate draw commands every frame.</td></tr><tr><td>r.MeshMerge.StoreImposterInfoInUVs</td><td>Determines whether or not to store imposter info (position.xy in UV2, position.z + scale in UV3) in the merged mesh UV channels<br>0: Do not store imposters info in UVs (default)<br>1: Store imposter info in UVs (legacy)<br></td></tr><tr><td>r.MeshParticle.MinDetailModeForMotionBlur</td><td>Sets the minimum detail mode before mesh particles emit motion blur (Low = 0, Med = 1, High = 2, Max = 3). Set to -1 to disable mesh particles motion blur entirely. Defaults to -1.</td></tr><tr><td>r.MeshReductionModule</td><td>Name of what mesh reduction module to choose. If blank it chooses any that exist.<br></td></tr><tr><td>r.MeshStreaming</td><td>Experimental - When non zero, enables mesh stremaing.<br></td></tr><tr><td>r.MinRoughnessOverride</td><td>WARNING: This is an experimental feature that may change at any time.<br>Sets a global limit for roughness when used in the direct lighting calculations.<br>This can be used to limit the amount of fireflies caused by low roughness, in particular when AA is not in use.<br>0.0: no change (default)</td></tr><tr><td>r.MinScreenRadiusForCSMDepth</td><td>Threshold below which meshes will be culled from CSM depth pass.</td></tr><tr><td>r.MinScreenRadiusForDepthPrepass</td><td>Threshold below which meshes will be culled from depth only pass.</td></tr><tr><td>r.MinScreenRadiusForLights</td><td>Threshold below which lights will be culled.</td></tr><tr><td>r.MinYResolutionFor3DView</td><td>Defines the smallest Y resolution we want to support in the 3D view</td></tr><tr><td>r.MinYResolutionForUI</td><td>Defines the smallest Y resolution we want to support in the UI (default is 720)</td></tr><tr><td>r.MipMapLODBias</td><td>Apply additional mip map bias for all 2D textures, range of -15.0 to 15.0</td></tr><tr><td>r.Mobile.AdrenoOcclusionMode</td><td>0: Render occlusion queries after the base pass (default).<br>1: Render occlusion queries after translucency and a flush, which can help Adreno devices in GL mode.</td></tr><tr><td>r.Mobile.AllowDistanceFieldShadows</td><td>0: Do not generate shader permutations to render distance field shadows from stationary directional lights.<br>1: Generate shader permutations to render distance field shadows from stationary directional lights. (default)</td></tr><tr><td>r.Mobile.AllowDitheredLODTransition</td><td>Whether to support 'Dithered LOD Transition' material option on mobile platforms</td></tr><tr><td>r.Mobile.AllowMovableDirectionalLights</td><td>0: Do not generate shader permutations to render movable directional lights.<br>1: Generate shader permutations to render movable directional lights. (default)</td></tr></tbody></table>

\
\
Generated by: Unreal Engine 5 console command 'Help'\
Version: 0.95\
Last Update: 2022.07.19-00.15.03
